{"meta":{"title":"无悔的博客小屋","subtitle":"协同快乐与伤悲","description":null,"author":"Kanarien","url":"http://Kanarienvogels.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-07-22T11:34:47.968Z","updated":"2018-07-22T11:34:47.968Z","comments":false,"path":"/404.html","permalink":"http://Kanarienvogels.github.io//404.html","excerpt":"","text":""},{"title":"about","date":"2018-07-22T09:07:12.000Z","updated":"2018-07-22T09:07:12.167Z","comments":true,"path":"about/index.html","permalink":"http://Kanarienvogels.github.io/about/index.html","excerpt":"","text":""},{"title":"search","date":"2018-07-22T05:54:31.000Z","updated":"2018-07-22T05:54:31.182Z","comments":true,"path":"search/index.html","permalink":"http://Kanarienvogels.github.io/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-22T09:07:21.000Z","updated":"2018-07-22T09:07:21.093Z","comments":true,"path":"tags/index.html","permalink":"http://Kanarienvogels.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Nginx搭配Tomcat作Web服务器","slug":"Nginx搭配Tomcat作Web服务器","date":"2018-07-22T13:11:28.690Z","updated":"2018-07-22T13:40:57.769Z","comments":true,"path":"2018/07/22/Nginx搭配Tomcat作Web服务器/","link":"","permalink":"http://Kanarienvogels.github.io/2018/07/22/Nginx搭配Tomcat作Web服务器/","excerpt":"0. 前言Nginx搭配Tomcat作Web服务器是项目部署在服务器上最常见的方式，为什么要使用Nginx呢？理由有不少，下面来分条讲讲：","text":"0. 前言Nginx搭配Tomcat作Web服务器是项目部署在服务器上最常见的方式，为什么要使用Nginx呢？理由有不少，下面来分条讲讲： 1. Nginx简介Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。 Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。 2. 为什么使用Nginx？使用Nginx的好处有三个： 反向代理 负载均衡 IO处理 另外，还可以参考：Nginx的一些基本功能 - CSDN博客 2.1 反向代理反向代理(Reverse Proxy)方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 反向代理是负载均衡的实现方式之一。 一个反向代理的服务器抛开所有业务层的东西，只单纯的接下请求再返回，即分离IO和业务，能够极大限度的使用服务器的性能。 2.2 负载均衡负载均衡(Load Balance)，其意思就是分摊到多个操作单元上进行执行。建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。 具体体现： 在Nginx设置文件中的upstream模块设置好各节点的权重以分发请求。 反向代理 2.3 IO处理对于后端是动态服务来说，比如Java和PHP。这类服务器（如JBoss和PHP-FPM）的IO处理能力往往不高。Nginx有个好处是它会把Request在读取完整之前buffer住，这样交给后端的就是一个完整的HTTP请求，从而提高后端的效率，而不是断断续续的传递（互联网上连接速度一般比较慢）。同样，Nginx也可以把response给buffer住，同样也是减轻后端的压力。 引用于 Nginx 反向代理为什么可以提高网站性能？ 3. Nginx的下载、配置、使用具体的下载、配置、使用可以参考以下网站： Nginx与tomcat组合的简单使用 - 李晓晖 - 博客园 Nginx的介绍和使用 - CSDN博客 你真的了解如何将 Nginx 配置为Web服务器吗 聪聪的个人网站 Copyright © 2018, CSCW back-end Kanarien, All Rights Reserved","categories":[{"name":"知识漫谈","slug":"知识漫谈","permalink":"http://Kanarienvogels.github.io/categories/知识漫谈/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://Kanarienvogels.github.io/tags/Nginx/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://Kanarienvogels.github.io/tags/Tomcat/"}]},{"title":"MongoDB数据的导出与导入（Unix 命令）","slug":"MongoDB数据的导出与导入","date":"2018-07-22T13:02:54.951Z","updated":"2018-07-22T13:37:35.207Z","comments":true,"path":"2018/07/22/MongoDB数据的导出与导入/","link":"","permalink":"http://Kanarienvogels.github.io/2018/07/22/MongoDB数据的导出与导入/","excerpt":"0. 前言某次项目需要从MongoDB导入导出数据，但发现可视化工具robot 3.x并没有提供数据的导入导出功能，只好上敲命令，期间遇到了点坑，以此记录下来。 1. 数据的导出1.1 准备操作打开windows命令窗口（或登录服务器用Unix命令行），转到mongo的bin文件夹下(如果直接配置好环境变量，可直接敲命令)使用mongodump命令(别急着按回车)","text":"0. 前言某次项目需要从MongoDB导入导出数据，但发现可视化工具robot 3.x并没有提供数据的导入导出功能，只好上敲命令，期间遇到了点坑，以此记录下来。 1. 数据的导出1.1 准备操作打开windows命令窗口（或登录服务器用Unix命令行），转到mongo的bin文件夹下(如果直接配置好环境变量，可直接敲命令)使用mongodump命令(别急着按回车) 1.2 mongodump基本语法1&gt; mongodump -h dbhost -d dbname -o dbdirectory -h： MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017 -d： 需要备份的数据库实例，例如：test -o：备份的数据存放位置，例如：c:\\data\\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。 如果直接输入mongodump命令，客户端会连接到ip为 127.0.0.1 端口号为 27017 的MongoDB服务上，并备份所有数据到 bin/dump/ 目录中。 1.3 注意点由于数据库往往带有账户密码，所以直接还要加上用户与密码参数。Mongo的参考文档中有：-u [ –username ] arg username -p [ –password ] arg password 下面举个例子 mongodump -d mydb -u root -p -o d:\\mydb 即使账号密码无误，这样子仍极有可能无法导出，提示中含有Authentication Fail (认证失败) 原因在于：仍缺少了一个重要的参数，没有指定身份权限认证的数据库。方法：补上 –authenticationDataBase admin即可。 比如： 成功的话可以看到目标目录有以数据库名字为名的文件夹以及bson和json文件 2. 数据的导入2.1 准备操作 既然是导入，那就得有导入的数据文件，其实就是导出的bson和json文件 安装好的mongo客户端(进入路径{mongoDB}/bin/或配置好环境变量) mongorestore命令 2.2 mongorestor基本语法1&gt; mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt; –host &lt;:port&gt;, -h &lt;:port&gt;：MongoDB所在服务器地址，默认为： localhost:27017–db , -d ：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2–drop：恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！ &lt;path&gt;：mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\\data\\dump\\test。你不能同时指定 &lt;path&gt; 和 –dir 选项，–dir也可以设置备份目录。–dir：指定备份的目录你不能同时指定 &lt;path&gt; 和 –dir 选项。 2.3 注意点 同导出操作1.3的注意点。如果设置了账号则要需要指明账号密码参数，并使用–authenticationDataBase admin 不需要指明导入到哪里，会自动导入到mongo的数据库中，如果数据(库)已存在则会覆盖 该命令恢复的数据是以数据库为单位的，即：恢复(导入)一整个数据库的数据 Copyright © 2018, CSCW back-end Kanarien, All Rights Reserved","categories":[{"name":"实践轨迹","slug":"实践轨迹","permalink":"http://Kanarienvogels.github.io/categories/实践轨迹/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://Kanarienvogels.github.io/tags/MongoDB/"},{"name":"Linux","slug":"Linux","permalink":"http://Kanarienvogels.github.io/tags/Linux/"}]},{"title":"Linux下系统信息、硬件信息的查看","slug":"Linux系统信息、硬件信息查看","date":"2018-07-22T12:53:00.371Z","updated":"2018-07-22T13:40:09.197Z","comments":true,"path":"2018/07/22/Linux系统信息、硬件信息查看/","link":"","permalink":"http://Kanarienvogels.github.io/2018/07/22/Linux系统信息、硬件信息查看/","excerpt":"0. 前言当刚接手一台新的服务器时，先认识下这台服务器的性能是很有必要的，特别是项目管理相关的事，对系统软硬件性能的不了解很可能导致出现差错，下面来简单介绍下Linux系统下系统信息、硬件信息的查看命令。 1. CPU相关信息 查看CPU个数cat /proc/cpuinfo | grep &quot;physical id&quot; | uniq | wc -l 示例输出：1 说明:这是查看记录CPU相关的文件(/proc/cpuinfo)的详细信息。cat 命令：查看文件内容；grep 命令：字符串拼接；uniq 命令：删除重复行；wc -l 命令：统计行数。通过查看cpu信息文件，根据物理核id（重复的不计）的个数获取物理核个数。","text":"0. 前言当刚接手一台新的服务器时，先认识下这台服务器的性能是很有必要的，特别是项目管理相关的事，对系统软硬件性能的不了解很可能导致出现差错，下面来简单介绍下Linux系统下系统信息、硬件信息的查看命令。 1. CPU相关信息 查看CPU个数cat /proc/cpuinfo | grep &quot;physical id&quot; | uniq | wc -l 示例输出：1 说明:这是查看记录CPU相关的文件(/proc/cpuinfo)的详细信息。cat 命令：查看文件内容；grep 命令：字符串拼接；uniq 命令：删除重复行；wc -l 命令：统计行数。通过查看cpu信息文件，根据物理核id（重复的不计）的个数获取物理核个数。 查看每个CPU物理核数cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniq 示例输出：cpu cores : 1 查看每个CPU逻辑核数cat /proc/cpuinfo | grep &quot;siblings&quot; | uniq 示例输出：siblings : 2 查看CPU逻辑核总个数cat /proc/cpuinfo | grep &quot;processor&quot; | uniq | wc -l 示例输出：2 说明：一般所说的CPU是几核指的是CPU逻辑核总数 查看CPU型号cat /proc/cpuinfo | grep &quot;model name&quot; |uniq 示例输出：model name : Intel(R) Xeon(R) CPU E5-2680 v3 @ 2.50GHz 举个总例子 以上输出表示，该服务器共有1个CPU（physical id 数目），每个CPU有1个物理核（cpu cores），每个物理核模拟2个逻辑核（siblings，使用超线程技术），型号为Intel芯片 E5-2680型，主频为2.50GHz。 2. 内存相关信息 查看内存大小、条数数量dmidecode | grep -P -A5 &quot;Memory Device&quot; | grep Size 示例输出： Size: 4096 MB 说明：dmidecode 命令是用来查看服务器硬件信息的，显示的都是结构化数据，但信息量相比其他命令较小，适合用于简单了解服务器基本硬件信息。 查看内存相关硬件信息dmidecode | grep -A16 &quot;Memory Device$&quot; 示例输出： 查看内存详细使用信息——1cat /proc/meminfo 示例输出(部分)： 说明：这是查看记录内存使用相关的文件(/proc/meminfo)的详细信息，由于信息过多，而且数据格式不易阅读，这里不赘述。值得一提的是，很多监控内存使用的命令都与此文件有关，如free 命令，使用这些命令可以跟和谐的查看内存使用情况。 查看内存详细使用信息——2free -m 示例输出： Mem参数说明 参数名 参数说明 1 total 所有可用的物理内存大小，总物理内存减去预留位和内核使用。操作系统本身（正文段、数据段等等）就会占用不少内存，此外还有系统各种保留的内存，把这些都去掉就是可用内存,对应 /proc/meminfo 中的MemTotal。另 total = used + free + shared + buff/cache 2 used 表示总计分配给缓存（包含buffers 与cache ）使用的数量，但其中可能部分缓存并未实际使用。 3 free 网上说是未被分配的内存，这样的说法可能不太准确，应该是当前空闲的内存数目，是系统层面上的空闲，对应 /proc/meminfo 中的MemFree 4 shared 共享内存，一般系统不会用到 5 buff/cache buff域描述的是块设备所占用的缓存，cache域描述的就是用于普通文件IO的page cache的数量，对应 /proc/meminfo 中的Buffers + Cached + MemFree 6 available 当前可用的内存总量（可用于分配给应用的，不包含虚拟内存），即应用层面上的可用的,CentOS 7 中有显示,对应 /proc/meminfo 中的MemAvailable 3. 系统相关信息 查看Linux内核版本cat /proc/version 示例输出： 查看发行版信息——1cat /etc/issue 示例输出：12CentOS release 6.7 (Final)Kernel \\r on an \\m 查看发行版信息——2cat /etc/redhat-release 示例输出：CentOS Linux release 7.2.1511 (Core) 说明：该命令只适合Redhat系的Linux 查看发行版信息——3cat /etc/os-release |grep VERSION 示例输出： 4. 硬盘相关信息 查看硬盘及分区信息fdisk -l 示例输出： 查看磁盘空间占用情况df -h 示例输出： 递归查看某路径下文件夹的磁盘空间占用情况du -h /usr/local/ 示例输出： 说明：该命令最后的参数是文件夹路径，显示出的路径是文件夹，不包括文件。再添加参数s，即du -sh /usr/local可以查看改路径下的总大小 Copyright © 2018, CSCW back-end Kanarien, All Rights Reserved","categories":[{"name":"知识漫谈","slug":"知识漫谈","permalink":"http://Kanarienvogels.github.io/categories/知识漫谈/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://Kanarienvogels.github.io/tags/Linux/"}]},{"title":"Java虚拟机——学习笔记","slug":"Java虚拟机——学习笔记","date":"2018-07-22T12:49:43.268Z","updated":"2018-07-22T13:40:43.364Z","comments":true,"path":"2018/07/22/Java虚拟机——学习笔记/","link":"","permalink":"http://Kanarienvogels.github.io/2018/07/22/Java虚拟机——学习笔记/","excerpt":"0. 前言Java 作为一门面向对象的语言被广泛的使用，知名企业中大量使用Java的有Amazon，Linkedin，阿里，美团，搜狐；用的比较少的知名企业有百度，腾讯等，可以说凡是大企业都或多或少的有用到Java。一些被广泛使用的开源系统、框架也完全使用Java进行编写，比如Android操作系统和Hadoop分布式系统基础框架。为什么Java会收到欢迎？除了其本身面向对象的特性极大的加快了开发效率这个表面原因，另一个重要的原因就是Java 虚拟机 (Java Virtual Machine)的存在，为程序提供了一个稳定健壮的运行环境。","text":"0. 前言Java 作为一门面向对象的语言被广泛的使用，知名企业中大量使用Java的有Amazon，Linkedin，阿里，美团，搜狐；用的比较少的知名企业有百度，腾讯等，可以说凡是大企业都或多或少的有用到Java。一些被广泛使用的开源系统、框架也完全使用Java进行编写，比如Android操作系统和Hadoop分布式系统基础框架。为什么Java会收到欢迎？除了其本身面向对象的特性极大的加快了开发效率这个表面原因，另一个重要的原因就是Java 虚拟机 (Java Virtual Machine)的存在，为程序提供了一个稳定健壮的运行环境。 Kanarien：其实我们Java程序员每天都用Java写程序，却很少有人会去了解这门语言的内在，毕竟重于计算机是一门实践性科学(整天敲代码)。应该找个空闲的时间来了解一下Java的底层架构，毕竟计算机科学同时也是一门理论性的学科(一堆的专业书)，是时候向Java高级方面迈进了！嘛，其实本人之所以会想了解JVM，原因还在于Java虚拟机与Java并发编程同时也是当今大数据时代的基础知识，是很重要的底层知识，顺应时代的潮流，我们有这个必要性去了解。 该文章结合了本人所学的知识，并参考了以下文章： Java 虚拟机面试题全面解析（干货） - CSDN博客 理解Java虚拟机体系结构 - LeoLiang - 博客园 JVM内存堆布局图解分析 - Sara早安 - 博客园 Java垃圾回收机制 - CSDN博客 图解Java 垃圾回收机制 - CSDN博客 该文章也借阅了书籍《深入理解Java虚拟机》，这里提供个人的pdf下载地址：《深入理解Java虚拟机》 1. Java 虚拟机概述1.1 任务概述Java 虚拟机的主要任务是装载class文件并且执行其中的字节码。由下图可以看出，Java虚拟机包含一个类装载器（class loader），它可以从程序和API中装载class文件，Java API中只有程序执行时需要的类才会被装载，字节码由执行引擎来执行。 当Java虚拟机由主机操作系统上的软件实现时，Java程序通过调用本地方法和主机进行交互。Java方法由Java语言编写，编译成字节码，存储在class文件中。本地方法由C/C++/汇编语言编写，编译成和处理器相关的机器代码，存储在动态链接库中，格式是各个平台专有。所以本地方法是联系Java程序和底层主机操作系统的连接方式。 由于Java虚拟机并不知道某个class文件是如何被创建的，是否被篡改一无所知，所以它实现了一个class文件检测器，确保class文件中定义的类型可以安全地使用。class文件检验器通过四趟独立的扫描来保证程序的健壮性：(详细见3.2.2类加载——连接之验证) class文件的结构检查 类型数据的语义检查 字节码验证 符号引用验证 Java 虚拟机在执行字节码时还进行其它的一些内置的安全机制的操作，他们作为Java编程语言保证Java 程序健壮性的特性，同时也是Java虚拟机的特性： 类型安全的引用转换 结构化的内存访问 自动垃圾收集 数组边界检查 空引用检查 1.2 功能概述 write once, run anywhere 一次编译， 到处运行 虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。正是得益于Java虚拟机，它号称的“一次编译，到处运行”才能有所保障。 1.3 Java 虚拟机的生命周期启动一个Java程序时，一个虚拟机实例也就诞生了。当该程序关闭退出，这个虚拟机实例也就随之消亡。如果同一台计算机上同时运行三个Java程序，将得到三个Java虚拟机实例。每个Java程序都运行于它自己的Java虚拟机实例中。 Java虚拟机实例通过调用某个初始类的main()方法来运行一个Java程序。而这个main()方法必须是共有的(public)、静态的(static)、返回值为void，并且接受一个字符串数组作为参数。任何拥有这样一个main()方法的类都可以作为Java程序运行的起点。 在以下几种情况下,Java 虚拟机将结束生命周期。 执行了System.exit()方法通过查看api文档,我们exit的参数为int,当参数为0就是正常结束,否则就是非正常结束。 程序正常结束 程序执行过程中遇到异常或错误 操作系统出现错误 1.4 Java 虚拟机与Java 程序Java程序的执行依赖于编译环境和运行环境。源码代码转变成可执行的机器代码，由下面的流程完成： Java技术的核心就是Java虚拟机，因为所有的Java程序都在虚拟机上运行。Java程序的运行需要Java虚拟机、Java API和Java Class文件的配合。Java虚拟机实例负责运行一个Java程序。当启动一个Java程序时，一个虚拟机实例就诞生了。当程序结束，这个虚拟机实例也就消亡。 Java的跨平台特性，因为它有针对不同平台的虚拟机。 1.5 虚拟机与物理机虚拟机是一个相对于物理机的概念，两种机器都具有执行代码的能力。区别在于物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统上的，而虚拟机的执行引擎是自己实现的，可自行定义指令集与执行引擎的结构体系。 2. JVM内存结构与对象2.1 数据运行时区域虚拟机的结构都是在内存中的一块空间，称为虚拟机内存结构，也称为数据运行时区域。 虚拟机的内存结构由五部分组成: 程序计数器 Java 虚拟机栈 本地方法栈 Java 堆 方法区 2.1.1 程序计数器程序计数器（Program Counter Register）是一块较小的内存空间，可以看作是当前线程所执行字节码的行号指示器。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。 由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各线程之间的计数器互不影响，独立存储。 如果线程正在执行的是一个 Java 方法，计数器记录的是正在执行的虚拟机字节码指令的地址； 如果正在执行的是 本地 方法，这个计数器的值为空。 程序计数器是唯一一个没有规定任何 内存溢出(OutOfMemoryError) 的区域。 2.1.2 Java虚拟机栈Java 虚拟机栈（Java Virtual Machine Stacks）是线程私有的，生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧（Stack Frame），存储 局部变量表 操作栈 动态链接 方法出口 每一个方法被调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 这个区域有两种异常情况： StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度 OutOfMemoryError：虚拟机栈扩展到无法申请足够的内存时 当程序在运行时抛出异常时，进行捕获时，经常会用到e.printStackTrace(),其输出的异常信息就是按对应线程的Java 虚拟机栈出栈输出的。 2.1.3 本地方法栈本地方法栈（Native Method Stacks）为虚拟机使用到的 本地(Native) 方法服务，是线程私有的。其与Java虚拟机栈类似，只不过Java 虚拟机栈为的是Java方法（字节码）服务 。不过，在虚拟机规范中，本地方法栈使用的语言、方式、数据结构没有绝对的规定，任何具体的虚拟机都可以自由实现。 2.1.4 Java 堆Java 堆（Java Heap）是 Java 虚拟机中内存最大的一块。Java 堆在虚拟机启动时创建，被所有线程共享。 作用：存放对象实例，也是唯一的目的。 垃圾收集器主要管理的就是 Java 堆。 Java 堆在物理上可以不连续，只要逻辑上连续即可。 2.1.5 方法区方法区（Method Area）被所有线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区也被叫做永久代，在Java堆之外，JDK8中已把方法区（永久代）移除，取而代之的是原数据区(Meta Space) 和 Java 堆一样，不需要连续的内存，可以选择固定的大小，更可以选择不实现垃圾收集。 2.1.6 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。保存 Class 文件中的符号引用、翻译出来的直接引用。运行时常量池可以在运行期间将新的常量放入池中。 2.1.7 直接内存直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现，所以我们放到这里一起讲解。 在JDK 1.4 中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O 方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java 堆里面的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java 堆和Native 堆中来回复制数据。显然，本机直接内存的分配不会受到Java 堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM 及SWAP 区或者分页文件）的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。 2.2 对象的创建new指令 =&gt; 类加载 =&gt; 内存分配 =&gt; 内存初始化 =&gt; 对象头设置 =&gt; 构造方法执行 2.2.1 类加载虚拟机遇到一个new指令时，首先会去检查这个指令的参数能否在常量池定位到一个符号引用，并检查这个符号引用代表的类是否已被加载、解析、初始化过，如果没有则进行类加载过程(见模块3)。 2.2.2 内存分配类加载通过后，为对象分配内存，对象所占的内存大小由类加载可完全确定。内存分配方式有两种：指针碰撞和空闲列表。 指针碰撞：若内存是绝对规整的，所有用过的内存在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，分配内存的动作即为指针向空闲空间那边挪动一小段与对象大小相等的距离。 空闲列表：若内存不是规整的，已使用的内存和空闲的内存相互交错，虚拟机通过一个列表记录内存的使用状况，分配内存时从列表中找出一块足够大的空间给对象实例并更新记录。 选择哪种分配方式由Java堆内存是否规整决定，而Java堆内存是否规整由所采用的垃圾收集器决定。使用Serial、ParNew等Compact过程的收集器，采用指针碰撞；使用CMS收集器等基于标记清除算法的收集器则采用空闲列表。 分配内存也要考虑到对象频繁创建时出现的线程安全问题。 2.2.3 内存初始化内存分配完毕后，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。保证对象的实例字段不赋初值就能够被访问到数据类型对应的零值。 2.2.4 对象头设置对对象进行必要的设置，比如：该对象是哪个类的实例、如何找到这个类的元信息、对象的哈希码、GC分代信息。这些信息都放置在对象头中。 2.2.5 构造函数执行以上操作完成后，从虚拟机角度来看，对象的创建已经完成了，但从Java程序的角度来讲，对象的创建才开始（虚拟机对上屏蔽了对象内存分配的细节），程序员通过执行构造函数来进行对象的初始化。 2.3 对象的内存布局对象在内存中的存储布局可分为3块：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）。 对象头（Header）：对象头包括两部分信息，一是对象自身运行时的数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。另一部分是类型指针，即对象指向它类元数据的指针，虚拟机通过这确定对象是哪个类的实例。 实例数据（Instance Data）：对象真正存储的有效信息，也是程序代码中定义的各种类型的字段内容。无论是父类的还是子类的数据都要记录。 对齐填充（Padding）：仅起着占位符的作用。对象起始地址必须是8字节的整数倍，对象头肯定是8字节的整数倍，而实例数据则不一定，此时用对齐填充来补全。 2.4 对象的访问程序中通过操作reference（引用）来操作对象，在Java堆内存中，对象的访问分为两种方式：句柄访问和直接访问。 句柄访问：Java堆中划分出一块内存作为句柄池，reference（引用）中存储的是对象的句柄地址，句柄包括了对象实例数据的地址和对象类型数据的地址。 直接指针访问： 使用句柄访问的好处是reference中存储的是稳定的句柄地址，对象被移动（如GC）只会改变实例数据指针的值，而不用reference本身的值。使用直接指针访问最大的好处是速度快。Hot Spot虚拟机采用的是直接指针访问 3. 类加载相关3.1 类装载器子系统类装载器子系统负责查找并装载类型信息。其实Java虚拟机有两种类装载器： 系统装载器 用户自定义装载器 前者是Java虚拟机实现的一部分，后者则是Java程序的一部分。 3.1.1 系统装载器Java 系统装载器主要有3种： 启动类装载器（bootstrap class loader）：也叫根装载器。它用来加载 Java 的核心库，是用原生代码（HotSpot 虚拟机使用C++）来实现的，并不继承自java.lang.ClassLoader。负责将存放在\\lib目录中的类库加载到虚拟机中。其无法被Java程序直接引用，无法直接获取。 扩展类装载器（extensions class loader）：是启动类装载器的子类。它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类,即负责加载\\lib\\ext目录中的所有类库，开发者可以直接使用。 应用程序类加载器（Application ClassLoader）：是扩展类装载器的子类。它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。默认情况下，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。 名词解释 —— HotSpot 虚拟机SunJDK和OpenJDK中自带的虚拟机，也是最被广泛使用的虚拟机。 一般说的启动类装载器加载器使用C++语言实现。这里只限于HotSpot,像MRP, Maxine等虚拟机, 整个虚拟机本身都是由Java编写的, 自然BootstrapClassLoader 也是由Java语言而不是C++实现的, 退一步讲, 除了HotSpot以外的其他两个高性能虚拟机JRockit和J9都有一个代表BootstrapClassLoader的java类存在, 但是关键方法的实现仍然是使用JNI回调到C, 不是C++的实现上, 这个BootstrapClassLoader的实例也无法被用户获取到。 3.1.2 用户自定义类装载器开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类装载器，以满足一些特殊的需求。 3.1.3 双亲委派模型我们的应用程序都是由4.1.1中的3种类加载器互相配合进行加载的, 如果有必要, 还可以加入自己定义的类加载器. 这些类加载器之间的关系是：12345graph TD boot(启动类装载器 bootstrap class loader) --&gt; ext(扩展类装载器 extensions class loader) ext --&gt; app(应用程序类加载器 Application ClassLoader) app --&gt; user1(用户自定义类加载器 User ClassLoader) app --&gt; user2(用户自定义类加载器 User ClassLoader) 双亲委派模型要求除了顶层的启动类加载器外,其余的类加载器都应当有自己的父类加载器. 这里类加载器之间的父子关系一般不会以继承(Inheritance)的关系来实现, 而是都使用组合(Composition)关系来复用父加载器的代码。 类加载器的双亲委派模型在JDK1.2期间被引入并被广泛应用于之后几乎所有的java程序中,但它并非不是一个强制性的约束模型,而是java设计者推荐给开发者的一种类加载器实现方式. 双亲委派模型的工作过程是 :如果一个类加载器收到了类加载的请求,它首先不会自己去尝试加载这个类, 而是把这个请求委派给父类加载器去完成, 每一个层次的类加载器都是如此, 因此所有的加载请求最都应该传送到顶层的启动类加载器中, 只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围内没有找到所需的类)时, 子加载器才会尝试自己去加载。 使用双亲委派模型的好处： java类随着它的类加载器一起具备了一种带有优先级的层次关系. 例如类Java.lang.Object,它存放在rt.jar之中, 无论哪一个类加载器要加载这个类, 最终都是委派给处于模型最顶端的启动类加载器进行加载, 由各个类加载器自行去加载的话,如果用户自己编写了一个称为java.lang.Object的类,并放在程序的classpath中,那系统中将会出现多个不同的Object类, java类型体系中最基础的行为也就无法保证, 应用程序也将会变得一片混乱。 实现非常简单,实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass()方法之中, 逻辑清晰。 从安全上考虑，有利于防止第三方往JVM中装载恶意的基础类。比如一个恶意的java.lang.String，由于双亲委派机制，基础类java.lang.String就会被往上请求加载，使用启动类装载器进行装载，从而避免恶意事件发生。 3.2 类加载机制Class文件描述的各种信息，都需要加载到虚拟机后才能运行。虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 在Java中类装载器把一个类装入JVM，有以下步骤： 加载: 查找并加载类的二进制数据 连接: 验证 确保被加载的类的正确性 准备 为类的静态变量分配内存,并将其初始化为默认值(int就是0 boolean就是 false 引用类型就是null) 解析 把类中的符号引用变为直接引用 初始化: 为类的静态变量赋予正确的初始值，只有在初始化阶段,赋值的=才发挥作用，且从上往下顺序执行。 理解起来应该没什么问题，那么 提问：在我们最开始编写java的时候总是javac命令编译成class字节码,java命令运行。如果java代码有什么问题,在javac的时候就会抛出问题,换句话说等我们连接class文件的时候它肯定是没问题的,那还验证什么呢？ 答案：如果class的产生只能通过javac命令的话,那就没有任何问题了,可关键就是人们也可以手动产生class文件,所以验证这一步还是有用的。 3.2.1 加载类的加载指的是通过一个类的全限定名来获取定义此类的二进制字节流，最一般的情况是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在Java 堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。也可以通过ZIP、JAR、WAR、网络(Applet)、JSP、或动态代理技术读取。 类的加载的最终产品是位于Java 堆区中的Class对象 名词解释 —— Class对象:每个类也都有一个描述自己信息的东西,它就是Class对象。这个类的Class对象里就包含了这个类里面有几个属性,每个属性是什么类型,有什么方法,每个方法的参数都是什么,返回值都是什么等等。如果有使用过反射类java.lang.Reflect中的对象与接口，对此应该不陌生。具体信息,参考JDK文档。 3.2.2 连接之验证这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 验证阶段大致会完成4个阶段的检验动作： 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔数0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外；是否继承了不允许继承的类（被final修饰的类）。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 3.2.3 连接之准备准备阶段是正式为类变量分配内存并设置类变量默认初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量。如：public static int a = 123;会被赋值为0（零值），赋值为123是在之后的初始化阶段，另外，如果是public static final int a = 123;则会赋值为123. 3.2.4 连接之解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。 再论符号引用、直接引用符号引用（Symbolic References）：在class文件中以CONSTANT_Class_info,CONSTANT_Fieldref_info等类型的常量出现。符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可，与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。 直接引用（Direct References）：直接引用可以是（1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）（2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）（3）一个能间接定位到目标的句柄直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。 3.2.5 初始化类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，变量已经付过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主管计划去初始化类变量和其他资源 初始化时机：Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才初始化他们。即主动引用。 主动引用包含以下六种情况： 创建类的实例 (如在代码中new Person()) 访问某个类或接口的静态变量，或者对该静态变量赋值 (Singlean.a=8) 调用类的静态方法 (Singleton.getInstance();) 反射（如Class.forName(“com.shengsiyuan.Test”) 初始化一个类的子类 (有father类,有child类,且child继承或实现father类。 ) Java虚拟机启动时被标明为启动类的类（调用java启动命令 如Java Test） 除此之外的引用方法都不会引起初始化，称为被动引用，比如： 通过子类引用父类的静态字段，不会导致子类的初始化； 通过数组定义来引用类，不会导致此类的初始化； 常量在编译时期会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此调用该常量不会触发定义常量的类的初始化。 类构造器&lt;clinit&gt;()是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}）中的语句合并产生的，顺序由语句在源文件出现的顺序决定，静态语句只能访问到在其之前定义的变量，但可以赋值。父类的类构造器会保证在子类的类构造器之前执行。类构造器在多线程环境会被加锁、同步，同时只有一个线程会去执行这个类的类构造器，且在同一类加载器中类构造器只会被调用一次。 3.2.6 类装载的具体例子&#123;.line-numbers&#125;123456789101112131415public class Singleton &#123; public static Singleton s=new Singleton(); public static int k1; public static int k2=0; private Singleton() &#123; k1++; k2++; &#125; public static void main(String[] args) &#123; System.out.println(Singleton.k1); System.out.println(Singleton.k2); &#125;&#125; 请问：输出是什么？ 解析：在连接的准备阶段 k1,k2都是0,s是null到了初始化阶段, 从上往下，s的初始化调用了构造函数，k1,k2都从0变成了1，继续往下，k1没有被赋值还是1，但是k2却被赋值为0了，所以最后的结果就是：1 0 4. 垃圾回收机制4.1 垃圾回收概述在C++中，对象所占的内存在程序结束运行之前一直被占用，在明确释放之前不能分配给其它对象。而在Java中，当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾。JVM的一个系统级线程会自动释放该内存块。垃圾回收意味着程序不再需要的对象是”无用信息”，这些信息将被丢弃。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用。事实上，除了释放没用的对象，垃圾回收也可以清除内存记录碎片。由于创建对象和垃圾回收器释放丢弃对象所占的内存空间，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存洞。碎片整理将所占用的堆内存移到堆的一端，JVM将整理出的内存分配给新的对象。 理解Java垃圾回收机制，需要明白下面三个问题： 在什么时候，什么区域？ (4.3 垃圾回收区域) 对什么东西？ (4.4 垃圾回收对象) 做了什么事情？ (4.5 垃圾回收算法 4.6 垃圾回收器) 在探讨Java垃圾回收机制之前，我们首先应该记住一个单词：Stop-the-World。Stop-the-world意味着 JVM由于要执行GC而停止了应用程序的执行，并且这种情形会在任何一种GC算法中发生。当Stop-the-world发生时，除了GC所需的线程以外，所有线程都处于等待状态直到GC任务完成。事实上，GC优化很多时候就是指减少Stop-the-world发生的时间，从而使系统具有 高吞吐 、低停顿 的特点。 4.2 垃圾回收意义Java技术体系中所提倡的 自动内存管理 最终可以归结为自动化地解决了两个问题：给对象分配内存 以及 回收分配给对象的内存。 垃圾回收机制的引入解决了第二个问题，可以有效的防止内存泄露、保证内存的有效使用，也大大解放了Java程序员的双手，使得他们在编写程序的时候不再需要考虑内存管理。 名词解析 —— 内存泄漏内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为“对象游离”。 4.3 垃圾回收区域说到垃圾回收发生的区域，有必要再述Java虚拟机内存结构中的Java堆和方法区。 4.3.1 再述Java堆Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。这个区域是用来存放对象实例的，几乎所有对象实例都会在这里分配内存。堆是Java垃圾收集器管理的主要区域（GC堆），垃圾收集器实现了对象的自动销毁。Java堆可以细分为：新生代和老年代；再细致一点的有Eden空间，From Survivor空间，To Survivor空间等。Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。可以通过-Xmx和-Xms控制 新生代（Young Generation）新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的。其中Eden区存放新生对象，Survivor区存放每次垃圾回收后存活的对象 老年代（Old Generation）老年代存放的都是一些生命周期较长的对象，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。 4.3.2 再述方法区方法区也叫永久代。在过去（自定义类加载器还不是很常见的时候），类大多是”static”的，很少被卸载或收集，因此被称为“永久的(Permanent)”。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。同时，由于类class是JVM实现的一部分，并不是由应用创建的，所以又被认为是“非堆(non-heap)”内存。HotSpot 虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。 永久代也是各个线程共享的区域，它用于存储已经被虚拟机加载过的类信息，常量，静态变量（JDK7中被移到Java堆），即时编译期编译后的代码（类方法）等数据。这里要讲一下运行时常量池，它是方法区的一部分，用于存放编译期生成的各种字面量和符号引用（其实就是八大基本类型的包装类型和String类型数据（JDK7中被移到Java堆））（官方文档说明： In JDK 7, interned strings are no longer allocated in the permanent generation of the Java heap, but are instead allocated in the main part of the Java heap (known as the young and old generations), along with the other objects created by the application）。 在JDK1.7中的HotASpot中，已经把原本放在方法区的字符串常量池移出。 将interned String移到Java堆中 将符号Symbols移到native memory（不受GC管理的内存） 从JDK7开始永久代的移除工作，贮存在永久代的一部分数据已经转移到了Java Heap或者是Native Heap。但永久代仍然存在于JDK7，并没有完全的移除：符号引用(Symbols)转移到了native heap;字面量(interned strings)转移到了java heap;类的静态变量(class statics)转移到了java heap。 随着JDK8的到来，JVM不再有永久代。但类的元数据信息（metadata）还在，只不过不再是存储在连续的堆空间上，而是移动到叫做“Metaspace”的本地内存（Native memory）中。 在JVM中共享数据空间划分如下图所示 4.4 垃圾回收种类由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。垃圾回收有两种类型，Minor GC 和 Full GC。 Minor GC：对新生代进行回收，不会影响到年老代。因为新生代的 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般在这里使用速度快、效率高的算法，使垃圾回收能尽快完成。 Full GC：也叫 Major GC，对整个堆进行回收，包括新生代、老年代和永久代。由于Full GC需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数，导致Full GC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。 4.5 垃圾回收时机那么对于 Minor GC 的触发条件：大多数情况下，直接在 Eden 区中进行分配。如果 Eden区域没有足够的空间，那么就会发起一次 Minor GC；对于 Full GC（Major GC）的触发条件：也是如果老年代没有足够空间的话，那么就会进行一次 Full GC。 上面所说的只是一般情况下，实际上，需要考虑一个空间分配担保的问题： 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。如果大于则进行Minor GC，如果小于则看HandlePromotionFailure设置是否允许担保失败（不允许则直接Full GC）。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则尝试Minor GC（如果尝试失败也会触发Full GC），如果小于则进行Full GC。 但是，具体到什么时刻执行，这个是由系统来进行决定，终究是无法预测的。 4.6 垃圾回收对象垃圾回收对象是可被回收的对象，判断对象可回收有两种算法： 引用计数算法：判断对象的引用数量 引用计数算法是通过判断对象的引用数量来决定对象是否可以被回收。 引用计数算法是垃圾收集器中的早期策略。在这种方法中，堆中的每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个引用变量，该对象实例的引用计数设置为 1。当任何其它变量被赋值为这个对象的引用时，对象实例的引用计数加 1（a = b，则b引用的对象实例的计数器加 1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数减 1。特别地，当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器均减 1。任何引用计数为0的对象实例可以被当作垃圾收集。 引用计数收集器可以很快的执行，并且交织在程序运行中，对程序需要不被长时间打断的实时环境比较有利，但其很难解决对象之间相互循环引用的问题。 可达性分析算法：判断对象的引用链是否可达 可达性分析算法是通过判断对象的引用链是否可达来决定对象是否可以被回收。 可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）。当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的，如下图所示。在Java中，可作为 GC Root 的对象包括以下几种： 虚拟机栈(栈帧中的局部变量表)中引用的对象； 方法区中类静态属性引用的对象； 方法区中常量引用的对象； 本地方法栈中Native方法引用的对象； 4.7 垃圾回收算法4.7.1 标记清除算法标记-清除算法分为标记和清除两个阶段。该算法首先从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象并进行回收 标记-清除算法的主要不足有两个： 效率问题：标记和清除两个过程的效率都不高; 空间问题：标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，因此标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 4.7.2 复制算法复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这种算法适用于对象存活率低的场景，比如新生代。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。该算法示意图如下所示： 事实上，现在商用的虚拟机都采用这种算法来回收新生代。因为研究发现，新生代中的对象每次回收都基本上只有10%左右的对象存活，所以需要复制的对象很少，效率还不错。正如在博文《JVM 内存模型概述》中介绍的那样，实践中会将新生代内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是 8:1，也就是每次新生代中可用内存空间为整个新生代容量的90% ( 80%+10% )，只有10% 的内存会被“浪费”。 4.7.3 标记整理算法复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。标记整理算法的标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾回收算法适用于对象存活率高的场景（老年代），其作用原理如下图所示。 标记整理算法与标记清除算法最显著的区别是：标记清除算法不进行对象的移动，并且仅对不存活的对象进行处理；而标记整理算法会将所有的存活对象移动到一端，并对不存活对象进行处理，因此其不会产生内存碎片。标记整理算法的作用示意图如下： 4.7.4 分代收集算法分代收集算法是一种综合策略，对于一个大型的系统，当创建的对象和方法变量比较多时，堆内存中的对象也会比较多，如果逐一分析对象是否该回收，那么势必造成效率低下。分代收集算法是基于这样一个事实：不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率。当代商用虚拟机使用的都是分代收集算法：新生代对象存活率低，就采用复制算法；老年代存活率高，就用标记清除算法或者标记整理算法。 1). 新生代（Young Generation） 新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的。新生代内存按照 8:1:1 的比例分为一个eden区和两个survivor(survivor0，survivor1)区，大部分对象在Eden区中生成。在进行垃圾回收时，先将eden区存活对象复制到survivor0区，然后清空eden区，当这个survivor0区也满了时，则将eden区和survivor0区存活对象复制到survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后交换survivor0区和survivor1区的角色（即下次垃圾回收时会扫描Eden区和survivor1区），即保持survivor0区为空，如此往复。特别地，当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代。如果老年代也满了，就会触发一次FullGC，也就是新生代、老年代都进行回收。注意，新生代发生的GC也叫做MinorGC，MinorGC发生频率比较高，不一定等 Eden区满了才触发。 2). 老年代（Old Generation） 老年代存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。此外，老年代的内存也比新生代大很多(大概比例是1:2)，当老年代满时会触发Major GC(Full GC)，老年代对象存活时间比较长，因此FullGC发生的频率比较低。 3). 永久代（Permanent Generation） 永久代主要用于存放静态文件，如Java类、方法等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如使用反射、动态代理、CGLib等bytecode框架时，在这种时候需要设置一个比较大的永久代空间来存放这些运行过程中新增的类。(注意：JDK8中，永久代已被完全移除) 4.8 垃圾回收器如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器之间的连线表示它们可以搭配使用。 Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效； Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本； ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现； Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景； Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本； CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。 G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。 5. Class文件5.1 无关性Java的无关性特性，准确的说应该是Java虚拟机的无关性特性，包括平台无关性与语言无关性，是建立在字节码（ByteCode）的基础之上的。平台无关性是指Java程序可以运行在任一种操作系统（平台）上，即所谓的”Write Once， Run Anywhere”。语言无关性是指Java虚拟机并不与包括Java语言在内的任何语言绑定，虽然很多程序员认为在Java虚拟机上运行Java程序是理所当然和天经地义的，但Java虚拟机实际上只和Class文件这种特殊的二进制文件关联。而且字节码比起Java语言具有更加强大的语言描述能力。 5.2 Class文件内容解析Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有任何分隔符，采用大端(Big-Endian)排序方案，即高位字节在地址最低位。 数据项目的结构与C语言的结构体类似。这种数据结构只有两种数据类型：无符号数和表，无符号数用u1、u2、u4、u8来分别表示1个字节、2个字节、4个字节、8个字节长度的无符号数，用来描述数字、索引应用、数量值或按照UTF-8编码构成字符串值。表是由多个无符号数或其他表作为数据项构成的复合数据类型，所有表习惯性地以“_info”结尾，整个Class文件实质上等同于一张表。 魔数（magic）：每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是用于确定这个文件是否为一个能被虚拟机接受的Class文件，值为OxCAFEBABE。 Class文件的版本（minor_version/major_version）：第5,6字节是次版本号（Minor Version），第7,8字节是主版本号（Major Version）,0x0033（十进制为51）表示JDK7，0x0032（十进制为50）表示JDK6。比如：0xCAFEBABE00000033,表示的是能被虚拟机接受的，次版本号为0x0000，主版本号为0x0033（JDK7）的Class文件的文件头。 常量池（constant_pool）：可理解为Class文件中的资源仓库，所占空间最大的项目之一。常量池有两类常量：字面量（Literal）和符号常量 （Symbolic References），字面量接近Java语言层面的常量概念，如：文本字符串、声明为final的常量值，符号引用属于编译原理的概念，包括三类常量： 类和接口的全限定名（Fully Qualified Name） 字段的名称和描述符（Descriptor） 方法的名称和描述符共有14种项目类型： 名词解释————全限定名、简单名称、描述符全限定名（Fully Qualified Name）：某个类的全名为pers.kanarien.study.TestClass，则全限定名为pers/kanarien/study/TestClass，多个全限定名使用”;”间隔简单名称：指没有类型或参数修饰的方法或字段名称，如方法test()和字段int a的简单名称分别为test和a描述符（Descriptor）：用来描述字段的数据类型、方法的参数列表（包括数量、类型、顺序）和返回值 访问标志（access_flags）：表示一个类或接口层次的访问信息，包括这个Class文件是类还是接口；是否定义为public类型；是否定义为abstract类型等 类索引（this_class）、父类索引（super_class）、接口索引集合（interfaces）：Class文件由以上三项确定继承关系。类索引用于确定这个类的全限定名；父类索引用于确定父类的全限定名；接口索引集合描述这个类实现了哪些接口。 字段表集合（field_info）：用于描述接口或类中声明的变量。字段包括类变量和实例级变量，不包括方法内的局部变量。字段包含的信息有：字段的作用域（public、private、protected修饰符）、实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。字段表结构如下： 字段表集合不会列出从超类或父接口中继承而来的字段，但可能列出Java代码中不存在的字段，比如内部类为了保持对外部类党的访问性，自动添加指向外部类实例的字段。另外，Java语言中字段是无法重载的，即两个字段的名称必须不一样，但对字节码来说，两个字段的描述符不一致，字段重名是合法的。 方法表集合（method_info）：与字段表集合类似，而方法中的Java代码存放在方法属性表一个名为“Code”的属性里面 属性表集合(attribute_info)：Class文件、字段表、方法表都可以拥有自己的属性表集合，属性表不要求有严格的顺序。对于每个属性，它的名称都是从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构是完全自定义的，只需一个u4的长度属性去说明属性值所占的位数即可。 Java虚拟机规范中定义的属性： Code属性：Java程序方法体中的代码经过Javac编译器处理后，最终变成字节码指令存储在Code属性内。 Code属性出现在方法表的属性表集合之中，但并非所有方法都有Code属性，比如接口和抽象类中的方法。一个实例方法，至少有一个参数和一个本地变量，原因是this关键字。任何实例方法内，都可以通过this关键字访问到此方法所属的对象，而Javac编译器编译的是否隐式的对this关键字的访问转变为对一个普通方法参数的访问，然后虚拟机在调用实例方法时自动传入此参数而已。Code属性有一个显式异常处理表(exception_info)如表6-16,用来实现Java异常和finally处理机制。 Exceptions属性：列举方法中可能抛出的受查异常，也就是方法描述时在throws关键字后面列举的异常。 LineNumberTable属性：用于描述Java源码行号与字节码行号（字节码偏移量）之间的对应关系。默认会生成到Class文件之中。如果不生成该属性，程序抛出异常时，堆栈不会显示行号，也无法设置断点调试程序。 5.3 字节码指令Java虚拟机的指令由一个字节长度的操作码，及其后若干的操作数组成。由于Java虚拟机采用面向操作数栈而不是寄存器的架构，因此大多数指令只有一个操作码，没有操作数。不考虑异常处理，Java虚拟机的最基本的执行模式如下伪代码所示123456do &#123; 自动计算PC寄存器的值加1； 根据PC寄存器指出的位置，从字节码流中取出操作码； if (字节码存在操作数) 从字节码流中读出操作数； 执行操作码定义的操作；&#125; while (字节码流长度 &gt; 0) Java虚拟机指令集中，大多数的指令的本身包含了其操作所对应的数据类型信息，如iload指令用于从局部变量表中加载int型数据到操作数栈，而fload用于float类型的数据。由于操作码长度只有1个字节(256种情况)，所以并非每一种数据类型和每一种操作都有对应的指令（Not Orthogonal） 。大部分指令都没有支持byte、char、short、boolean，编译器会在编译期或运行期将byte、char、short、boolean扩展为int型数据，其数组转换为int型数组，即byte、char、short、boolean类型的数据操作，实际上是使用相应的int型作为运算类型。 5.4 Java虚拟机的实现方式Java虚拟机的实现方式有两种： 将输入的Java虚拟机的代码在加载或执行时翻译成另一种虚拟机的指令集。 将输入的Java虚拟机的代码在加载或执行时翻译成宿主机CPU的本地指令集 6. 字节码执行引擎执行引擎在执行Java代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备。 6.1 栈帧栈帧（Stack Frame）是虚拟机运行时数据区中虚拟机栈中的处理元素，存储了局部变量表、操作数栈、动态链接和方法返回地址等信息。每一个方法的调用开始到完成的过程，对应着一个栈帧在虚拟机栈从入栈到出栈的过程。 6.1.1 局部变量表局部变量表（Local Variable Table）是一组变量值存储空间，存放方法的参数和方法内的局部变量。局部变量表的容量以变量槽（Variable Slot，简称Slot）为单位，大小一般为32位或64位，要求是一个Slot可以存放一个32位以内的数据类型。虚拟机通过索引定位的方式使用局部变量表，索引值范围从0到最大的Slot数量。对实例方法而言，第0位索引是对对象实例本身的引用，即this，其后按顺序依次为方法的参数和方法体内的局部变量。 不使用的对象应手动置为null ————《Practical Java》 这句话看起来很奇怪，实际上这与Slot的重用（内存的重用）有关。在同一个方法体内，后面的代码有一些耗时很长的操作，而前面的代码又定义了大量内存、实际上已经不会再使用的变量，手动置为null值，把变量对应的Slot清空，让Slot占用的空间能够被其他变量复用。需要注意的是，这种手动置null的用法仅在某种特殊的情况下使用，理由有两点： 恰当的变量作用域来控制变量回收时间才是最优雅的解决办法； 代码经过JIT编译器后，会对代码产生很大程度上的优化，置null值的操作会被JIT编译优化后消除掉。 另外，局部变量不同于类变量，如果一个局部变量定义了但没有赋初值是不能使用的（没有系统默认值），好在编译时就会有提醒。 6.2 方法调用方法调用不等于方法执行，方法调用唯一的目的是确定被调用的方法的版本（调用哪一个方法），而不涉及方法内部的执行。一切方法在Class文件中只是符号引用，需要找出对应的直接引用才能执行。 6.2.1 再论类加载的解析类加载的解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。而该时期解析的方法是非虚方法，即 静态方法 私有方法 实例构造器 父类方法 final修饰的方法除此之外的方法属于虚方法。解析调用在编译时期就完全确定，在类加载时期的解析阶段就好将符号引用替换为直接引用，不需要等到运行期。 6.2.2 静态分派（静态绑定）虚方法的静态分派（静态绑定）与Java面向对象特性中的重载密切相关，发生在编译期。看下面的一段代码，试想输出是什么。&#123;.line-numbers&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.jvm;/** * 静态分派 * */public class StaticDispatch &#123; static class Human &#123; &#125; static class Man extends Human &#123; &#125; static class Women extends Human &#123; &#125; public void sayHello(Human guy) &#123; System.out.println(\"hello, guy!\"); &#125; public void sayHello(Man guy) &#123; System.out.println(\"hello, man!\"); &#125; public void sayHello(Women guy) &#123; System.out.println(\"hello, women!\"); &#125; public static void main(String[] args)&#123; Human man = new Man(); Human women = new Women(); StaticDispatch sd = new StaticDispatch(); sd.sayHello(man); sd.sayHello(women); &#125;&#125; 输出&#123;.line-numbers&#125;12hello, guy!hello, guy! 上面代码中的“Human”称为变量的静态类型（Static Type），后面的Man称为变量的实际类型（Actual Type）。静态类型的最终类型在编译期是可知的，但实际类型只在运行期才确定。，虚拟机（准确来说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判断依据的。另外，对于字面量，如sayHello(&#39;a&#39;)中的a参数，由于其本身不需要定义，故没有显示的静态类型，因此编译器只能选择更接近、更合适的类型的方法来调用。 对应的字节码指令是invokestatic或invokespecial加符号引用 6.2.3 动态分派（动态绑定）虚方法的动态分派（动态绑定）与Java面向对象特性中的重写密切相关，发生在运行期。看下面的一段代码，试想输出是什么。&#123;.line-numbers&#125;123456789101112131415161718192021222324252627282930313233343536373839404142package com.jvm;/** * 动态分派 * @author renhj * */public class DynamicDispatch &#123; static abstract class Human &#123; protected abstract void sayHello(); &#125; static class Man extends Human &#123; @Override protected void sayHello() &#123; System.out.println(\"hello man!\"); &#125; &#125; static class Women extends Human &#123; @Override protected void sayHello() &#123; System.out.println(\"hello women!\"); &#125; &#125; public static void main(String[] args)&#123; Human man = new Man(); Human women = new Women(); man.sayHello(); women.sayHello(); man = new Women(); man.sayHello(); &#125;&#125; 输出&#123;.line-numbers&#125;123man say hellowoman say hellowoman say hello 相同的静态类型调用同一方法却输出不同结果，原因是重写使用动态分配的方式，根据实际类型去调用相关的方法，字节码对应的指令为invokevirtual加上符号引用 6.2.4 动态类型语言动态类型语言的特征是类型检查的主体过程是在运行期而不是编译期，比如JavaScript、PHP、Ruby、Groovy等。动态类型语言编译时最多只确定方法名称、参数、返回值等信息，而不会去确定方法所在的具体类型（方法接受者不固定）。可理解为：“变量无类型而变量值才有类型”。 静态类型语言在编译器确定好类型，编译器可提供严谨的类型检查，利于稳定性与大规模的代码；动态类型语言运行期确定类型，为开发人员提供更大的灵活性，代码更加的简洁、清晰。 Java属于动态类型语言，JDK7中提供的java.lang.invoke包中提供的API实现了一定程度上动态语言的特性，JDK7以前单纯依靠符号引用来确定调用的目标方法，而invoke包提供了一种新的动态确定目标方法的机制，称为“MethodHandle”（可获得一个虚方法的句柄），为JDK8的Lambda表达式提供了实现基础。 6.3 解释执行Java被定位为“解释执行”的语言，但随着技术的发展，主流的虚拟机都包括了JIT编译器，Class文件的代码到底是解释执行还是编译执行只能虚拟机自己才知道了。 典型的解释执行概念模型中，一个实例方法中的简单的四则远算的具体执行步骤如下： 操作数入操作数栈； 操作数栈中的操作数存入局部变量Slot； 所有操作数都存入完毕后，从局部变量表加载所需要的数据到操作数栈； 以栈顶两个操作数为一次运算的运算元素进行运算，结果放栈顶，重复运算知道算出最终结果； 返回栈顶元素。 6.3.1 编译过程现大多高级语言都遵循经典编译原理，在执行前对源码进行词法分析和语法分析，把源码转换为抽象语法树，如下图所示。其中最下方的路径为生成目标机器代码的过程，代表语言C/C++；中间的路径就是解释执行，代表语言Java；又或者把这些步骤和执行引擎一起封装，如JavaScript执行器。 6.3.2 基于栈的指令集与基于寄存器的指令集Java虚拟机使用基于栈的指令集，而主流的PC大都使用基于寄存器的指令集。 使用基于寄存器的指令集有以下优点： 可移植性高，不必依赖硬件寄存器； 编译器实现简单； 代码更加紧凑（字节码大都是单字节） 使用基于寄存器的指令集一个显著的缺点是执行效率慢，原因有： 完成相同功能需要更多的指令； 频繁访存。 7. 编译期优化Java语言的编译期是一段不确定的操作过程，因为它可能是指一个前端编译器（或叫编译器的前端）把 .java文件 转变成 .class文件 的过程；也可能是虚拟机的后端运行期编译器（JIT编译器，Just in Time Compiler）把字节码抓变成机器码的过程；还可能是指使用静态提前编译器（AOT编译器，Ahead Of Time Compiler） 直接把 *.java 文件编译成本地机器代码的过程。具体有： 前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）； JIT编译器：HotSpot VM的C1、C2编译器； AOT编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。 7.1 Sun Javac 编译过程虚拟机严格定义了Class文件的格式，但并没有对如何把Java源码转变为Class文件的编译过程进行严格的定义。某些情况下，会出现Javac编译器可以编译而ECJ编译器不可编译的问题。 对Sun Javac而言，编译过程如图所示： 主体代码如下： 7.1.1 解析和填充符号表词法分析词法分析是将源代码的字符流转变为标记（Token）集合，标记是编译过程的最小元素，如：关键字、变量名、字面量、运算符。 语法分析语法分析是根据Token序列构造抽象语法树（Abstract Syntax Tree，AST）的过程，AST用来描述程序代码语法结构的树形表示方式，每一节点代表程序代码中的一个语法结构 填充符号表符号表（Symbol Table）是由一组符号地址和符号信息构成的表格，类似哈希表的K-V形式。在语义分析阶段，符号表用来语义检查和产生中间代码；在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。 7.1.2 注解处理器在JDK5之后，Java提供了注解（Annotation）的支持，这些注解和普通的Java代码一样，在运行期发挥作用，。在JDK6中，提供的插入时注解处理器在编译期对注解进行处理，可以把插入式注解处理器看成一组编译器的插件，能够插入、修改、读取抽象语法树的任一元素。每次处理称为一个Round，也就是Sun Javac编译过程中的回环。 7.1.3 语义分析语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的检查，包括标注检查和数据及控制流检查。 标注检查：标注检查的步骤包括如变量使用前是否声明、变量与赋值类型是否匹配等，以及需要特别说明的常量折叠。如果在代码中写了int _2kb = 1024 * 2;，经常量折叠后，表达式的值会在语法树上标注出来（ConstantValue：2048），由于在编译期进行了常量折叠，并不会在运行期增加CPU的运算量。 数据及控制流分析：数据及控制流分析是对程序上下文逻辑更进一步的验证，可以检查出如程序局部变量在使用前是否赋值、方法的每条路径是否都有返回值、是否所有受查异常都被正确处理等。编译期的数据及控制流分析与类加载时的数据及控制流分析基本一致，但校检范围有所区别，有一些校检项只在编译期或运行期进行。 解语法糖：语法糖（Syntactic Sugar），也称糖衣语法。指计算机语言中添加的某种语法，这种语法对语言功能并没有影响，但更方便程序员的使用，增加程序可读性，在Java中有如：泛型、变长参数、自动装箱/拆箱等。在编译阶段将语法糖还原回简单的基础语法结构，称为解语法糖。 7.1.4 字节码生成Javac编译的最后一个阶段，将生成的语法树、符号表转化成Class文件，以及少量的代码添加、转换工作，如实例构造器&lt;init()&gt;和类构造器&lt;clinit()&gt;就是在这阶段添加到语法树中。 7.2 Java语法糖——糖衣背后的真实语法糖虽然不会提供实质性的功能改进，但它们或能提高效率，或能提升语法的严谨性，或能减少编码出错的机会。但我们也要认清糖衣背后的真实，看清程序的真面目。 7.2.1 泛型与类型擦除泛型是JDK5的一项新特性，本质是参数化类型（Parametersized Type）的应用。在Java语言还没有泛型的时候，通过Object是所有类型的父类以及强制类型转换配合使用实现泛型化。在C#和Java中的泛型有着根本性的区别，C#的泛型无论在源码中、编译后、运行时都是真实存在的，List&lt;Integer&gt;和List&lt;String&gt;是两个不同的类型，在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，；Java的泛型只存在于源码中，编译后的Class文件中已经变为原生类型了，并且在相应地方加入了强制类型转换，对于运行期的Java语言来说，List&lt;Integer&gt;和List&lt;String&gt;是同一个类，这种实现方法称为类型擦除，属于伪泛型。 下面举一个例子说明，类型擦除前的代码： 由编译出的Class文件，再反编译回去的代码： 当泛型遇上重载，如下代码：&#123;.line-numbers&#125;1234567public void method(List&lt;String&gt; list) &#123; ...&#125;public void method(List&lt;Integer&gt; list) &#123; ...&#125; 是不能通过编译的，因为类型擦除后，方法的参数都是List（对于JDK6而言，如果返回类型不一样是能够编译的，原因在于描述符不同的方法在Class文件中能够共存，之后的版本不可编译）。 另外类型擦除通过Java虚拟机规范后来加入的两个属性：Signature和LocalVariableTypeTable，可以通过反射获得实际的类型参数而不是原生类型。 7.2.2 遍历循环与变长参数遍历循环（Foreach）使用关键字for( : )实现，变长参数指方法的参数长度不定，如下代码：&#123;.line-numbers&#125;1234List&lt;Integer&gt; list = Arrays.asList(new Integer(1), new Integer(2), new Integer(3));for (Integer i : list) &#123; System.out.println(i.toString());&#125; 由编译出的Class文件，再反编译回去的代码：&#123;.line-numbers&#125;12345678910List list = Arrays.asList(new Integer[] &#123; new Integer(1), new Integer(2), new Integer(3)&#125;);for (Iterator localIterator = list.iterator(); localIterator.hasNext(); ) &#123; Integer i = ((Integer)localIterator.next()); System.out.println(i.toString());&#125; 显然，遍历循环是依赖Iterable接口实现的，而变长参数语法是通过数组完成的。 7.2.3 * 自动装箱、自动拆箱与“==”、“equals()”自动装箱指的是用基本类型的值给它的包装类赋值时，系统会自动将基本类型转换成它的包装类型。实际上，系统自动调用Integer.valueOf()方法来完成转换。JDK源码如下:&#123;.line-numbers&#125;12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 先判断能不能冲缓存中获取，否则new一个Integer对象。 关于IntegerCache的源码如下：&#123;.line-numbers&#125;1234567891011121314151617181920212223242526272829static final int low = -128;static final int high;static final Integer cache[];static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127;&#125; 意思是，默认情况下创建一个Integer数组的缓存，默认情况下该缓存的内容是值为-128到127的Integer对象。 自动拆箱和自动装箱相反，当需要基本类型的时候，系统也会自动的将包装类转换成基本类型。实际上，系统自动调用Integer.intValueOf方法来完成转换。JDK源码如下:&#123;.line-numbers&#125;123public int intValue() &#123; return value;&#125; 再来看下“==”和“equals()” ==运算符，如果是基本数据类型，则直接对值进行比较，如果是引用数据类型，则是对他们的地址进行比较（但是只能比较相同类型的对象，或者比较父类对象和子类对象。类型不同的两个对象不能使用==） equals()方法，继承自Object类，在具体实现时可以覆盖父类中的实现。看一下Object中qeuals的源码发现，它的实现也是对对象的地址进行比较，此时它和”==”的作用相同。而JDK类中有一些类覆盖了Object类的equals()方法，比较规则为：如果两个对象的类型一致，并且内容一致，则返回true,这些类有：java.io.file,java.util.Date,java.lang.string，包装类（Integer,Double等）。 看如下代码，思考输出：&#123;.line-numbers&#125;12345678910111213141516171819202122public static void main(String args[]) &#123; Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321; Long g = 3L; int x = 3; long y = 3L; //x,y虽然类型不同但是可以直接进行数值比较 System.out.println(x == y); //true，int类型向long类型对齐，从二进制角度表示来看，显然值相等 //System.out.println(c == g); 提示出错，不可比较的类型。说明此时没有自动拆箱 System.out.println(c == d); //true，两个在IntegerCache范围的的Integer类型进行比较，同一个引用地址进行比较 System.out.println(e == f); //false，两个不在IntegerCache范围的的Integer类型进行比较，不同引用地址进行比较 System.out.println(c == (a+b)); //true，有“+”运算符，“a+b”自动拆箱后进行运算，变量“c”也自动拆箱，对值进行比较 System.out.println(c.equals(a+b)); //true，有“+”运算符，“a+b”自动拆箱后进行运算，对值进行自动装箱，对对象类型以及值进行比较 //此时进行了自动的拆箱 System.out.println(g == (a+b)); //true，有“+”运算符，“a+b”自动拆箱后进行运算，对值进行比较 System.out.println(g.equals(a+b)); //false，有“+”运算符，“a+b”自动拆箱后进行运算，对值进行自动装箱，对对象类型以及值进行比较 &#125; 7.2.4 条件编译Java语言也有条件编译，方法是也只是条件为常量的if语句，具体例子如下代码：&#123;.line-numbers&#125;1234567public static void main(String[] args) &#123; if (true) &#123; System.out.println(\"block1\"); &#125; else &#123; System.out.println(\"block2\"); &#125;&#125; 由编译出的Class文件，再反编译回去的代码如下：&#123;.line-numbers&#125;123public static void main(String[] args) &#123; System.out.println(\"block1\");&#125; 由于使用了if语句，所以只能写在方法体内，实现语句块（Block）级别的条件编译，而没办法实现根据条件调整整个Java类的结构。 8. 运行期优化8.1 JIT编译器当虚拟机发现某个方法或代码块的运行特别频繁的时候，就会把这些代码认定为热点代码（Hot Spot Code）。为了提高热点代码的执行效率，运行时虚拟机会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器叫做即时编译器（Just In Time Compiler，JIT编译器）。 Java虚拟机规范并没有规定Java虚拟机时候一定要有JIT编译器，更没有规定具体实现的细节，但JIT编译器性能的好坏，代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键指标之一，也是虚拟机中最核心、最能体现虚拟机技术水平的部分。 8.2 解释器与编译器主流的虚拟机很多都采用解释器与编译器并存的架构。当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译时间，立即执行；程序运行后，随着时间推移，编译器逐渐发挥作用，把越来越多代码编译成本地代码，可以获取更高的执行效率。当程序运行环境中内存限制较大，可以使用解释执行节省内存，反之使用编译执行提升效率。另外，当激进优化的假设不成立时，可通过逆优化退回到解释状态继续执行。 三大商用虚拟机中的JRockit内部没有解释器，它主要面向服务端的应用，这类应用一般不重点关注启动时间。 HotSpot虚拟机中内置了两个JIT编译器，分别称为Client Compiler和Server Compiler，或简称为C1编译器和C2编译器（也叫Opto编译器）。为了在程序启动响应速度和运行效率之间取得平衡，HotSpot虚拟机采用分层编译（Tiered Compilation）策略。分层编译根据编译器编译、优化的规模和耗时，划分出不同编译层次，包括： 第0层，程序解释执行，解释器不开启性能监控功能，可触发第1层编译。 第1层，也称为C1编译，将字节码编译成本地代码，进行简单的、可靠的优化，如有必要加入性能监控逻辑。 第2层（或以上），也称为C2编译，也是将字节码编译成本地代码，但会开启一些编译耗时较长的优化，甚至根据性能监控信息开启一些不可靠的激进优化。 8.3 编译对象与触发条件被JIT编译器编译的代码有两类： 被多次调用的方法 被多次执行的循环体 对于第一种情况，由于是方法调用触发的编译，编译器会把整个方法当成编译的对象（JIT标准编译方式）；对于第二种情况，编译器仍会以整个方法作为编译对象，但由于发生在循环体执行的过程中，因此形象地称为栈上替换（On Stack Reaplacement，OSR）。 判断代码是不是热点代码，是否需要出发即时编译，称为热点探测（Hot Spot Detection），主要有两种方式： 基于采样的热点探测（Sample Based Hot Spot Detection）：虚拟机会周期性检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那个方法就是热点方法。优点：实现简单、高效，容易获取方法调用关系，缺点：难以精确确认一个方法的热度，易受线程阻塞和外界因素干扰。 基于计数器的热点探测（Counter Based Hot Spot Detection）：为每个方法（甚至代码块）建立计数器，统计方法的执行次数，执行次数超过一定的阈值就是热点方法。优点:统计结果精确严谨，缺点：实现麻烦，为每个方法维护一个计数器，不能直接获取方法调用关系。 Hot Spot虚拟机使用基于计数器的热点探测，为每个方法准备了两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter） 显然，方法调用计数器统计的是方法调用的次数，方法调用计数器触发即时编译的流程图如下： 缺省情况下，当超过一定的时间限度，方法调用次数不足以触发即时编译，则方法计数会减少一半，称为计数器的热度衰减（Counter Decay），这段时间称为半衰周期（Counter Half Life Time） 回边计数器统计一个方法中循环体代码执行的次数，回边指的是在字节码中遇到控制流向后跳转的指令，其触发流程与方法调用计数器类似。但回边计数器没有热度衰减。 8.4 编译过程编译未完成时，仍以解释执行的方式去执行。Client Compiler的编译过程分为三个阶段： Server Compiler专门面向服务端的应用而特别调整，较为复杂，会执行所有经典的优化动作，虽然编译速度比Client Compiler慢，但比静态优化编译器要快得多。 8.5 编译技术8.5.1 公共子表达式消除如果一个表达式E已经计算过，并且从先前的计算到现在的E中所有变量的值都没有发生变化，那么E的这次出现就成为了公共子表达式。对于这种表达式，直接使用前面计算的结果代替即可。举个例子，有以下的计算式：1int s = (c * b) * 12 + a + (a + b * c); 可优化为1int s = E * 12 + a + (a + E); 8.5.2 数组边界检查消除Java是一门动态安全的语言，对数组的读写访问不像C/C++那样本质是裸针操作。在访问数组的时候，系统会自动进行上下界检查，即隐式的条件判断，对有大量的数组访问操作的代码来说，这会一定程度上影响到性能，但又不能不检查。但实际上，不是每次访问数组都必须要检查一遍的，比如：数组下标是个常量，编译期根据数据流分析判断是否越界，运行期就不用判断了。又如数组访问发生在循环中，使用循环变量进行访问，同样通过数据流分析判断循环变量是否在数组大小范围内，就可以消除检查。 8.5.3 方法内联方法内联是编译器最重要的优化手段之一，除了消除方法调用的成本外，还为其他优化手段建立基础。方法内联的优化行为看似很简单，不过是把目标方法的代码“复制”到发起调用的方法之中，避免发生真实的方法调用。但实际上，除了之前说过的非虚方法，其他方法在调用时都要进行方法接收者的多态选择，并且可能存在多个方法版本，特别是动态分派的重写方法，只能在运行期判断方法接收者是子类还是父类。 为了解决虚方法的方法内联问题，Java虚拟机团队引入了一种名为“类型继承分析”（Class Hierarchy Analysis，CHA）的技术，用于确定在目前已加载的类中，某接口是否有多于一种的实现，某个类是否存在子类等信息。 编译器在进行内联时，非虚方法直接内联，虚方法则向CHA查询是否有多个方法版本，如果查询结果只有一个，则可以进行内联，不过这种内联属于激进优化，需要预留一个“逃生门”，称为守护内联（Guarded Inlining），如果后续的程序加载了导致继承关系发生变化的新类，那就需要抛弃已经编译的代码，退回解释执行或重新编译。如果CHA查询结果有多个结果可以选择，编译器会使用内联缓存来完成方法内联，工作原理为：未发生方法调用前，内联缓存为空，当第一次方法调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较方法接收者的版本，如果方法接受者的版本一样，那这个内联可以一直用下去，否则取消内联，查找虚方法表进行方法分派。 8.5.4 逃逸分析逃逸分析（Escape Analysis）的基本行为是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为参数传递到其他方法，称为方法逃逸；甚至可能被外部线程访问，譬如赋值给类变量或可以在其他线程中访问到的实例变量，称为线程逃逸。 如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问这个对象，则可对这个对象做些优化： 栈上分配（Stack Allocation）：让对象在栈上分配而不是在堆上，对象所占的内存虽栈帧出栈而释放。 同步消除（Synchronization Elimination）：一个变量不会逃逸出线程，那这个变量的读写就不会有竞争，对这个变量实施的同步措施就可以消除掉。 标量替换（Scalar Replacement）：标量（Scalar）是指一个数据已经无法再分解成更小的数据来表示了，如：Java虚拟机中的原始类型（int、long等基本数据类型以及引用类型）。相对的，如果一个数据可以继续分解，那么它就被称作聚合量（Aggregate），如Java中的对象。将一个Java对象拆散，根据程序访问的情况，将使用到的成员变量恢复原始类型来访问就叫标量替换。 Copyright © 2018, GDUT CSCW back-end Kanarien, All Rights Reserved","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Kanarienvogels.github.io/categories/学习笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://Kanarienvogels.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://Kanarienvogels.github.io/tags/JVM/"}]},{"title":"Spring整合Netty、WebSocket的互联网聊天系统","slug":"Spring整合Netty、WebSocket的互联网聊天系统","date":"2018-07-22T12:02:36.405Z","updated":"2018-07-22T13:41:12.934Z","comments":true,"path":"2018/07/22/Spring整合Netty、WebSocket的互联网聊天系统/","link":"","permalink":"http://Kanarienvogels.github.io/2018/07/22/Spring整合Netty、WebSocket的互联网聊天系统/","excerpt":"0.前言最近一段时间在学习Netty网络框架，又趁着计算机网络的课程设计，决定以Netty为核心，以WebSocket为应用层通信协议做一个互联网聊天系统，整体而言就像微信网页版一样，但考虑到这个聊天系统的功能非常多，因此只打算实现核心的聊天功能，包括单发、群发、文件发送，然后把项目与Spring整合做成开源、可拓展的方式，给大家参考、讨论、使用，欢迎大家的指点。","text":"0.前言最近一段时间在学习Netty网络框架，又趁着计算机网络的课程设计，决定以Netty为核心，以WebSocket为应用层通信协议做一个互联网聊天系统，整体而言就像微信网页版一样，但考虑到这个聊天系统的功能非常多，因此只打算实现核心的聊天功能，包括单发、群发、文件发送，然后把项目与Spring整合做成开源、可拓展的方式，给大家参考、讨论、使用，欢迎大家的指点。 关于Netty Netty 是一个利用 Java 的高级网络的能力，隐藏其背后的复杂性而提供一个易于使用的 API 的客户端/服务器框架。 这里借用《Essential Netty In Action》的一句话来简单介绍Netty，详细的可参考阅读该书的电子版 Essential Netty in Action 《Netty 实战(精髓)》 关于WebSocket通信协议简单说一下WebSocket通信协议，WebSocket是为了解决HTTP协议中通信只能由客户端发起这个弊端而出现的，WebSocket基于HTTP5协议，借用HTTP进行握手、升级，能够做到轻量的、高效的、双向的在客户端和服务端之间传输文本数据。详细可参考以下文章： WebSocket 是什么原理？为什么可以实现持久连接？ WebSocket 教程 - 阮一峰的网络日志 1. 技术准备 操作平台：Windows 7, 64bit 8G IDE：MyEclipse 2016 JDK版本：1.8.0_121 浏览器：谷歌浏览器、360浏览器（极速模式）（涉及网页前端设计，后端开发表示很苦闷） 涉及技术： Netty 4 WebSocket + HTTP Spring MVC + Spring JQuery Bootstrap 3 + Bootstrap-fileinput Maven 3.5 Tomcat 8.0 2. 整体说明2.1 设计思想整个通信系统以Tomcat作为核心服务器运行，其下另开一个线程运行Netty WebSocket服务器，Tomcat服务器主要处理客户登录、个人信息管理等的HTTP类型请求（通常的业务类型），端口为8080，Netty WebSockt服务器主要处理用户消息通信的WebSocket类型请求，端口为3333。用户通过浏览器登录后，浏览器会维持一个Session对象（有效时间30分钟）来保持登录状态，Tomcat服务器会返回用户的个人信息，同时记录在线用户，根据用户id建立一条WebSocket连接并保存在后端以便进行实时通信。当一个用户向另一用户发起通信，服务器会根据消息内容中的对话方用户id，找到保存的WebSocket连接，通过该连接发送消息，对方就能够收到即时收到消息。当用户注销或退出时，释放WebSocket连接，清空Session对象中的登录状态。 事实上Netty也可以用作一个HTTP服务器，而这里使用Spring MVC处理HTTP请求是出于熟悉的缘故，也比较接近传统开发的方式。 2.2 系统结构系统采用B/S（Browser/Server），即浏览器/服务器的结构，主要事务逻辑在服务器端（Server）实现。借鉴MVC模式的思想，从上至下具体又分为视图层（View）、控制层（Controller）、业务层（Service）、模型层（Model）、数据访问层（Data Access） 2.3 项目结构项目后端结构： 项目前端结构： 2.4 系统功能模块系统只包括两个模块：登录模块和聊天管理模块。 登录模块：既然作为一个系统，那么登录的角色认证是必不可少的，这里使用简单、传统的Session方式维持登录状态，当然也有对应的注销功能，但这里的注销除了清空Session对象，还要释放WebSocket连接，否则造成内存泄露。 聊天管理模块：系统的核心模块，这部分主要使用Netty框架实现，功能包括信息、文件的单条和多条发送，也支持表情发送。 其他模块：如好友管理模块、聊天记录管理、注册模块等，我并没有实现，有兴趣的话可以自行实现，与传统的开发方式类似。 到这里，可能会有人出现疑问了，首先是前面的涉及技术中没有ORM框架（Mybatis或Hibernate），这里又没有实现好友管理的功能，那用户如何确定自己的好友并发送信息呢？其实，这里我在dao层的实现里并没有连接数据库，而是用硬编码的方式固定好系统的用户以及用户的好友表、群组表，之所以这么做是因为当初考虑到这个课程设计要是连接数据库就太麻烦了光是已有的模块（包括前后端）就差不多3k行代码了，时间上十分划不来，于是就用了硬编码的方式偷懒，后面会再说明系统用户的情况。 2.5 用户状态转换图由于本系统涉及多个用户状态，有必要进行说明，下面给出本系统的用户状态转换图。 2.6 系统界面系统聊天界面如下： 3. 核心编码3.1 Netty WebSocket服务端3.1.1 Netty服务器启动与关闭不得不说的是，当关闭Tomcat服务器时，也要释放Netty相关资源，否则会造成内存泄漏，关闭方法如下面的close()，如果只是使用shutdownGracefully()方法的话，关闭时会报内存泄露Memory Leak异常（但IDE可能来不及输出到控制台）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * 描述: Netty WebSocket服务器 * 使用独立的线程启动 * @author Kanarien * @version 1.0 * @date 2018年5月18日 上午11:22:51 */public class WebSocketServer implements Runnable&#123; private final Logger logger = LoggerFactory.getLogger(WebSocketServer.class); @Autowired private EventLoopGroup bossGroup; @Autowired private EventLoopGroup workerGroup; @Autowired private ServerBootstrap serverBootstrap; private int port; private ChannelHandler childChannelHandler; private ChannelFuture serverChannelFuture; // 构造方法少了会报错 public WebSocketServer() &#123;&#125; @Override public void run() &#123; build(); &#125; /** * 描述：启动Netty Websocket服务器 */ public void build() &#123; try &#123; long begin = System.currentTimeMillis(); serverBootstrap.group(bossGroup, workerGroup) //boss辅助客户端的tcp连接请求 worker负责与客户端之前的读写操作 .channel(NioServerSocketChannel.class) //配置客户端的channel类型 .option(ChannelOption.SO_BACKLOG, 1024) //配置TCP参数，握手字符串长度设置 .option(ChannelOption.TCP_NODELAY, true) //TCP_NODELAY算法，尽可能发送大块数据，减少充斥的小块数据 .childOption(ChannelOption.SO_KEEPALIVE, true)//开启心跳包活机制，就是客户端、服务端建立连接处于ESTABLISHED状态，超过2小时没有交流，机制会被启动 .childOption(ChannelOption.RCVBUF_ALLOCATOR, new FixedRecvByteBufAllocator(592048))//配置固定长度接收缓存区分配器 .childHandler(childChannelHandler); //绑定I/O事件的处理类,WebSocketChildChannelHandler中定义 long end = System.currentTimeMillis(); logger.info(\"Netty Websocket服务器启动完成，耗时 \" + (end - begin) + \" ms，已绑定端口 \" + port + \" 阻塞式等候客户端连接\"); serverChannelFuture = serverBootstrap.bind(port).sync(); &#125; catch (Exception e) &#123; logger.info(e.getMessage()); bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); e.printStackTrace(); &#125; &#125; /** * 描述：关闭Netty Websocket服务器，主要是释放连接 * 连接包括：服务器连接serverChannel， * 客户端TCP处理连接bossGroup， * 客户端I/O操作连接workerGroup * * 若只使用 * bossGroupFuture = bossGroup.shutdownGracefully(); * workerGroupFuture = workerGroup.shutdownGracefully(); * 会造成内存泄漏。 */ public void close()&#123; serverChannelFuture.channel().close(); Future&lt;?&gt; bossGroupFuture = bossGroup.shutdownGracefully(); Future&lt;?&gt; workerGroupFuture = workerGroup.shutdownGracefully(); try &#123; bossGroupFuture.await(); workerGroupFuture.await(); &#125; catch (InterruptedException ignore) &#123; ignore.printStackTrace(); &#125; &#125; public ChannelHandler getChildChannelHandler() &#123; return childChannelHandler; &#125; public void setChildChannelHandler(ChannelHandler childChannelHandler) &#123; this.childChannelHandler = childChannelHandler; &#125; public int getPort() &#123; return port; &#125; public void setPort(int port) &#123; this.port = port; &#125;&#125; 3.1.2 Netty服务器处理链独立出处理器链类，方便修改与注入，免得混在一起显得混乱。12345678910111213141516171819@Componentpublic class WebSocketChildChannelHandler extends ChannelInitializer&lt;SocketChannel&gt;&#123; @Resource(name = \"webSocketServerHandler\") private ChannelHandler webSocketServerHandler; @Resource(name = \"httpRequestHandler\") private ChannelHandler httpRequestHandler; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(\"http-codec\", new HttpServerCodec()); // HTTP编码解码器 ch.pipeline().addLast(\"aggregator\", new HttpObjectAggregator(65536)); // 把HTTP头、HTTP体拼成完整的HTTP请求 ch.pipeline().addLast(\"http-chunked\", new ChunkedWriteHandler()); // 分块，方便大文件传输，不过实质上都是短的文本数据 ch.pipeline().addLast(\"http-handler\", httpRequestHandler); ch.pipeline().addLast(\"websocket-handler\",webSocketServerHandler); &#125;&#125; 3.1.3 Netty服务器HTTP请求处理器值得一提的是，当在处理链中使用Spring注入处理器的bean的时候，如果处理器类不使用@Sharable标签的话，会出现错误。如果不使用Spring注入bean的方式，那么应该new一个新的处理器对象，如ch.pipeline().addLast(&quot;http-handler&quot;, new HttpRequestHandler())。另外，判断HTTP请求还是WebSocket请求的方式稍微不太优雅，但我按照《Essential Netty in Action》中的方法去试，结果有问题的，只好用下面的if语句判断。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Component@Sharablepublic class HttpRequestHandler extends SimpleChannelInboundHandler&lt;Object&gt; &#123; /** * 描述：读取完连接的消息后，对消息进行处理。 * 这里仅处理HTTP请求，WebSocket请求交给下一个处理器。 */ @Override protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception &#123; if (msg instanceof FullHttpRequest) &#123; handleHttpRequest(ctx, (FullHttpRequest) msg); &#125; else if (msg instanceof WebSocketFrame) &#123; ctx.fireChannelRead(((WebSocketFrame) msg).retain()); &#125; &#125; /** * 描述：处理Http请求，主要是完成HTTP协议到Websocket协议的升级 * @param ctx * @param req */ private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) &#123; if (!req.decoderResult().isSuccess()) &#123; sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.BAD_REQUEST)); return; &#125; WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory( \"ws:/\" + ctx.channel() + \"/websocket\", null, false); WebSocketServerHandshaker handshaker = wsFactory.newHandshaker(req); Constant.webSocketHandshakerMap.put(ctx.channel().id().asLongText(), handshaker);// 保存握手类到全局变量，方便以后关闭连接 if (handshaker == null) &#123; WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel()); &#125; else &#123; handshaker.handshake(ctx.channel(), req); &#125; &#125; private void sendHttpResponse(ChannelHandlerContext ctx, FullHttpRequest req, DefaultFullHttpResponse res) &#123; // 返回应答给客户端 if (res.status().code() != 200) &#123; ByteBuf buf = Unpooled.copiedBuffer(res.status().toString(), CharsetUtil.UTF_8); res.content().writeBytes(buf); buf.release(); &#125; // 如果是非Keep-Alive，关闭连接 boolean keepAlive = HttpUtil.isKeepAlive(req); ChannelFuture f = ctx.channel().writeAndFlush(res); if (!keepAlive) &#123; f.addListener(ChannelFutureListener.CLOSE); &#125; &#125; /** * 描述：异常处理，关闭channel */ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 3.1.4 Netty服务器WebSocket请求处理器考虑到规范性与可维护性，switch语句中的case常量应该放在常量类中声明比较好，这里偷懒了。另外说下群发的逻辑（属于业务逻辑，这里没有给出代码），群发也就是在一个群中发言，后端会扫描群中在线的用户，逐一发送信息。用户的WebSocket连接（即ChannelHandlerContext对象），会保存在全局变量onlineUserMap中，以用户id作键，方便操作连接。关于表情的发送逻辑，与单发逻辑相同，不同的是发送内容为对应的img标签字符串。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110@Component@Sharablepublic class WebSocketServerHandler extends SimpleChannelInboundHandler&lt;WebSocketFrame&gt; &#123; private static final Logger LOGGER = LoggerFactory.getLogger(WebSocketServerHandler.class); @Autowired private ChatService chatService; /** * 描述：读取完连接的消息后，对消息进行处理。 * 这里主要是处理WebSocket请求 */ @Override protected void channelRead0(ChannelHandlerContext ctx, WebSocketFrame msg) throws Exception &#123; handlerWebSocketFrame(ctx, msg); &#125; /** * 描述：处理WebSocketFrame * @param ctx * @param frame * @throws Exception */ private void handlerWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) throws Exception &#123; // 关闭请求 if (frame instanceof CloseWebSocketFrame) &#123; WebSocketServerHandshaker handshaker = Constant.webSocketHandshakerMap.get(ctx.channel().id().asLongText()); if (handshaker == null) &#123; sendErrorMessage(ctx, \"不存在的客户端连接！\"); &#125; else &#123; handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain()); &#125; return; &#125; // ping请求 if (frame instanceof PingWebSocketFrame) &#123; ctx.channel().write(new PongWebSocketFrame(frame.content().retain())); return; &#125; // 只支持文本格式，不支持二进制消息 if (!(frame instanceof TextWebSocketFrame)) &#123; sendErrorMessage(ctx, \"仅支持文本(Text)格式，不支持二进制消息\"); &#125; // 客服端发送过来的消息 String request = ((TextWebSocketFrame)frame).text(); LOGGER.info(\"服务端收到新信息：\" + request); JSONObject param = null; try &#123; param = JSONObject.parseObject(request); &#125; catch (Exception e) &#123; sendErrorMessage(ctx, \"JSON字符串转换出错！\"); e.printStackTrace(); &#125; if (param == null) &#123; sendErrorMessage(ctx, \"参数为空！\"); return; &#125; String type = (String) param.get(\"type\"); switch (type) &#123; case \"REGISTER\": chatService.register(param, ctx); break; case \"SINGLE_SENDING\": chatService.singleSend(param, ctx); break; case \"GROUP_SENDING\": chatService.groupSend(param, ctx); break; case \"FILE_MSG_SINGLE_SENDING\": chatService.FileMsgSingleSend(param, ctx); break; case \"FILE_MSG_GROUP_SENDING\": chatService.FileMsgGroupSend(param, ctx); break; default: chatService.typeError(ctx); break; &#125; &#125; /** * 描述：客户端断开连接 */ @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; chatService.remove(ctx); &#125; /** * 异常处理：关闭channel */ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125; private void sendErrorMessage(ChannelHandlerContext ctx, String errorMsg) &#123; String responseJson = new ResponseJson() .error(errorMsg) .toString(); ctx.channel().writeAndFlush(new TextWebSocketFrame(responseJson)); &#125;&#125; 3.1.5 文件上传文件上传的思路是先把文件上传到服务器上，再返回给对方文件的url以及相关信息。文件上传并没有使用WebSocket连接来上传，而是直接使用HTTP连接结合Spring的接口简单的实现了，可自行修改实现使用WebSocket连接来上传文件。另外，文件保存的路径是http://localhost:8080/WebSocket/UploadFile，如果Tomcat端口不是8080或者想改变存储路径的话，请注意修改常量。 1234567891011121314151617181920212223242526272829303132333435363738@Servicepublic class FileUploadServiceImpl implements FileUploadService&#123; private final static String SERVER_URL_PREFIX = \"http://localhost:8080/WebSocket/\"; private final static String FILE_STORE_PATH = \"UploadFile\"; @Override public ResponseJson upload(MultipartFile file, HttpServletRequest request) &#123; // 重命名文件，防止重名 String filename = getRandomUUID(); String suffix = \"\"; String originalFilename = file.getOriginalFilename(); String fileSize = FileUtils.getFormatSize(file.getSize()); // 截取文件的后缀名 if (originalFilename.contains(\".\")) &#123; suffix = originalFilename.substring(originalFilename.lastIndexOf(\".\")); &#125; filename = filename + suffix; String prefix = request.getSession().getServletContext().getRealPath(\"/\") + FILE_STORE_PATH; System.out.println(\"存储路径为:\" + prefix + \"\\\\\" + filename); Path filePath = Paths.get(prefix, filename); try &#123; Files.copy(file.getInputStream(), filePath); &#125; catch (IOException e) &#123; e.printStackTrace(); return new ResponseJson().error(\"文件上传发生错误！\"); &#125; return new ResponseJson().success() .setData(\"originalFilename\", originalFilename) .setData(\"fileSize\", fileSize) .setData(\"fileUrl\", SERVER_URL_PREFIX + FILE_STORE_PATH + \"\\\\\" + filename); &#125; private String getRandomUUID() &#123; return UUID.randomUUID().toString().replace(\"-\", \"\"); &#125;&#125; 3.2 WebSocket客户端3.2.1 浏览器客户端代码下面只展示核心的websocket连接代码。补充说明：考虑到浏览器的兼容性，经测试，建议使用谷歌浏览器和360浏览器（极速模式），火狐浏览器和IE11的界面有点问题。也说明一下，UI设计的排版是从网上找的，由修改了下，自己呕心沥血的用JS补充了动态功能，包括： 新消息红标签提醒 新消息置顶 客户端保存已发聊天记录 用户己方聊天信息靠左，接收信息靠右 聊天信息框的宽度动态计算详细可见chatroom.js文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;script type=\"text/javascript\"&gt; var userId; var socket; var sentMessageMap; setUserInfo(); setSentMessageMap(); if(!window.WebSocket)&#123; window.WebSocket = window.MozWebSocket; &#125; if(window.WebSocket)&#123; socket = new WebSocket(\"ws://localhost:3333\"); socket.onmessage = function(event)&#123; var json = JSON.parse(event.data); if (json.status == 200) &#123; var type = json.data.type; console.log(\"收到一条新信息，类型为：\" + type); switch(type) &#123; case \"REGISTER\": ws.registerReceive(); break; case \"SINGLE_SENDING\": ws.singleReceive(json.data); break; case \"GROUP_SENDING\": ws.groupReceive(json.data); break; case \"FILE_MSG_SINGLE_SENDING\": ws.fileMsgSingleRecieve(json.data); break; case \"FILE_MSG_GROUP_SENDING\": ws.fileMsgGroupRecieve(json.data); break; default: console.log(\"不正确的类型！\"); &#125; &#125; else &#123; alert(json.msg); console.log(json.msg); &#125; &#125;; // 连接成功1秒后，将用户信息注册到服务器在线用户表 socket.onopen = setTimeout(function(event)&#123; console.log(\"WebSocket已成功连接！\"); ws.register(); &#125;, 1000) socket.onclose = function(event)&#123; console.log(\"WebSocket已关闭...\"); &#125;; &#125; else &#123; alert(\"您的浏览器不支持WebSocket！\"); &#125;&lt;/script&gt; 4. 效果及操作演示4.1 登录操作登录入口为：http://localhost:8080/WebSocket/login 或 http://localhost:8080/WebSocket/当前系统用户固定为9个，群组1个，包括9人用户。 用户1 用户名：Member001 密码：001 用户2 用户名：Member002 密码：002······ 用户9 用户名：Member009 密码：009 4.2 聊天演示 4.3 文件上传演示 5.补充为了使项目具有更好的可拓展性、可读性、可维护性，很多地方都使用Spring的Bean进行注入，也运用了面向接口编程的思想，当运用上Mybatis等ORM框架的时候，直接修改dao层实现即可，无需改动其他地方，同时也在适当的地方加上了注释。 最后附上git源码地址：Kanaien GitHub Copyright © 2018, GDUT CSCW back-end Kanarien, All Rights Reserved","categories":[{"name":"实践轨迹","slug":"实践轨迹","permalink":"http://Kanarienvogels.github.io/categories/实践轨迹/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://Kanarienvogels.github.io/tags/Tomcat/"},{"name":"Spring","slug":"Spring","permalink":"http://Kanarienvogels.github.io/tags/Spring/"},{"name":"Netty","slug":"Netty","permalink":"http://Kanarienvogels.github.io/tags/Netty/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://Kanarienvogels.github.io/tags/WebSocket/"}]},{"title":"Redis——学习笔记","slug":"Redis——学习笔记","date":"2018-07-22T07:22:46.610Z","updated":"2018-07-22T13:41:05.243Z","comments":true,"path":"2018/07/22/Redis——学习笔记/","link":"","permalink":"http://Kanarienvogels.github.io/2018/07/22/Redis——学习笔记/","excerpt":"0. 前言此笔记用来记录关于Redis的一些基本认识、知识。记录会比较详细，请恰当的使用目录与查找工具（ctrl + f），同时该笔记会随时间的推进而不断补充。具体的使用请参考其他关于Redis使用的笔记。 更新记录 2018.2.14 初次记录 2018 4.21 重新对目录进行了分级，补充了4.Redis执行效率，以及其他章节的细节","text":"0. 前言此笔记用来记录关于Redis的一些基本认识、知识。记录会比较详细，请恰当的使用目录与查找工具（ctrl + f），同时该笔记会随时间的推进而不断补充。具体的使用请参考其他关于Redis使用的笔记。 更新记录 2018.2.14 初次记录 2018 4.21 重新对目录进行了分级，补充了4.Redis执行效率，以及其他章节的细节 1. Redis简单介绍 Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 Redis官方网站：redis.io 名词解析————BSD协议BSD开源协议是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。当你发布使用了BSD协议的代码，或者以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：A.如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。B.如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。C.不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。 2. Redis常用数据结构和操作在介绍数据类型之前，先让我们来看看Redis k-v数据结构中非常重要的key形式。 2.1 Key的命名规则 key不要太长。在redis中可以的最大容量是512M，但是实际中key超过1024byte就非良好的设计方式了。key值太大不仅浪费内存空间，更是在请求中对于key’的查找需要更多的时间进行比较； key值不宜太短。这个原则貌似与第一条相冲突，实则不然。有时key的变长使得增加空间相对于使得key更具可读性更显次要； key的命名中可以使用冒号和破折号加以细分，使key更具可读性，灵活性。例如：aticle:1000:tags。其中第一位表示类型，第二位表示该类型对象的Id，第三位表示Id为1000的文章中的标记； 2.2 Key的常用命令 * – 命令 说明 1 EXISTS exists主要是查找指定的键是否存在，如果存在则返回(Integer) 1，否则返回(Integer) 0。 2 DEL del主要用来删除Key，并将Key对应的值随之删除。 3 EXPIRE expire设置Key的有效期，如果超过设定的存活时间，Key将自动失效并随之删除。 4 TTL 查看键的过期时间 5 PERSIST 取消键的过期时间，即持久化 6 KEYS * 匹配键所有的键. 模糊匹配 KEYS my* 取出所有已my开头的键 7 PING 检验是否成功连接上客户端，正常则返回PONG 这些都是redis的常用命令，值得先记住 2.3 Redis常用数据结构和操作命令和参数之间、参数和参数之间用空格分隔 2.3.1 String最普通的key-value类型，说是String，其实是任意的byte[]，比如图片，最大512M。 所有常用命令的复杂度都是O(1)，普通的Get/Set方法，可以用来做Cache。 value参数可以含有双引号也不含有 常用命令： – 命令 说明 1 SET 设置键值对，若键值已存在则会覆盖值 2 GET 通过键获取值 3 MSET 设置多个键值对 一块存错 全成功,全失败。如MSET name kanarien age 20 4 SETNX 设置键值对 5 STRLEN 返回键对应的值得字符长度 6 APPEND 给键对应的值后追加值 7 INCR 使键对应的值自增1，前提是值可看作Integer 8 INCRBY 使键对应的值增加给定的值，前提是值可看作Integer。如：INCRBY age 3给age对应的值加上3 2.3.2 Lists基于Linked List链式节点实现的List数据结构。相对于缓存或者数据库系统而言，在插入或者更新的操作上性能更重要，相对于查询操作，查询所带来的性能损耗更低。平衡性能的确采用Linked List实现更具有优越性。redis中复合类型的基元素都是String类型。Lists也不例外。Lists类型实质就是一串String元素的序列，redis提供了很多丰富命令，用于操作Lists类型。 常用命令： – 命令 说明 1 LPUSH 从链表的头部(左)压入 2 RPUSH 从链表的尾部(右)压入 3 LPOP 从链表的头部(左)弹出一个元素 4 RPOP 从链表的尾部(右)弹出一个元素 5 LLEN 返回这个链表的元素的长度 6 LRANGE 获取List中的范围元素，第二个参数表示要查找元素的起始位，第三个元素表示结束位。如：LRANGE mylist1 0 -1 获取所有元素 2.3.3 Hashesredis中的Hashes类型类似Java中map，key-value键值对映射型数据结构。redis提供了很多命令用于操作Hashes。常常利用Hashes来映射一个简单的Java对象。 常用命令： – 命令 说明 1 HMSET 向Hashes中插入元素。如：HMSET usr:001 username kanarien birth 1997 sex male 2 HGET 获取Hashes中的单个元素。如：HGET usr:001 username 3 HMGET 获取Hashes中的多个元素。如：HMGET usr:001 username birth sex 4 HLEN 返回hash表的所有的字段的数目 5 HKEYS 返回hash表的所有字段 6 HVALS 返回hash表中所有的值 7 HGETALL 返回所有的字段和值 8 HDEL 对hash的name的值和键删除 2.3.4 SetsSet类型是无序且无重复的String元素的集合。redis也提供了大量对于Sets类型的操作，比如：交集、并集、补集在多个Set之间；测试给定元素是否存在等。 常用命令： – 命令 说明 1 SADD 向Set中插入新的元素，如果有则覆盖，其中可以接多个参数作为插入的元素 2 SREM 删除集合中的一个元素 3 SISMEMBER 测试指定元素在Set中是否存在 4 SMEBERS 获取Set中的所有元素，并且是无序的 5 SINTER 取多个Set的交集 2.3.5 Sorted SetSorted Set类型是有序的Set类型，有点像Hashes和Set的混合型数据结构。具有Set的唯一无重复特性，且有序的实现是通过额外的浮点值被称作为score决定，与Hashes的Key有点相似。 Sorted Set的排序规则，假设有两个元素a、b 如果a.score &gt; b.score，则a &gt; b; 如果a.score = b.score，a &gt; b，则a &gt; b; 常用命令： – 命令 说明 1 ZADD 向Set中插入新的元素，如果有则覆盖，其中可以接多个参数作为插入的元素 2 ZREM 删除集合中的一个元素 3 ZRANGE 获取Sorted Set中的元素 4 ZREVRANGE 获取Sorted Set中元素并反向输出 3. Redis事务用Multi(Start Transaction)、Exec(Commit)、Discard(Rollback)实现。 在事务提交前，不会执行任何指令，只会把它们存到一个队列里，不影响其他客户端的操作。在事务提交时，批量执行所有指令。 注意，Redis里的事务，与我们平时的事务概念很不一样： 它仅仅是保证事务里的操作会被连续独占的执行。因为是单线程架构，在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的。 它没有隔离级别的概念，因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题。 它不保证原子性——所有指令同时成功或同时失败，只有决定是否开始执行全部指令的能力，没有执行到一半进行回滚的能力。 在redis里失败分两种，一种是明显的指令错误，比如指令名拼错，指令参数个数不对，在2.6版中全部指令都不会执行。 另一种是隐含的，比如在事务里，第一句是SET foo bar， 第二句是LLEN foo，对第一句产生的String类型的key执行LLEN会失败，但这种错误只有在指令运行后才能发现，这时候第一句成功，第二句失败。 还有，如果事务执行到一半redis被KILL，已经执行的指令同样也不会被回滚。 Watch指令，类似乐观锁，事务提交时，如果Key的值已被别的客户端改变，比如某个list已被别的客户端push/pop过了，整个事务队列都不会被执行。 4. Redis执行效率Redis的运行效率十分之高，官方提供的数据是可以达到100000+的qps，实际应用中上也能轻松达到每秒上万次的读操作，而Redis之所以能迅速的处理，理由有以下三点： 数据存放在内存中，绝大部分请求是纯粹的内存操作 单进程单线程架构，避免了不必要的上下文切换和竞争条件 网络IO中使用了I/O 多路复用（IO multiplexing） 下面来说明第二点和第三点 4.1 Redis架构 设计是一场与复杂性的战斗 出于Redis作者Salvatore Sanfilippo自身的考量,Redis采用了单线程的架构，使得代码看起来十分的洁简与优美。 详细的来说，Redis为单进程单线程模式，是线程安全的，采用队列模式将并发访问变为串行访问。当然，可以通过在服务端开启多个Redis的实例来实现达到多进程并行访问，但若真有这种情况，请考虑是否有此必要。另外，正因为Redis本身是单进程单线程的，利用此特性可以将一些并发的问题转化成串行处理，达到消除并发带来的各种问题的效果。 单进程单线程好处 代码更清晰，处理逻辑更简单 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗 不存在多进程或者多线程导致的切换而消耗CPU 单进程单线程弊端 无法发挥多核CPU性能 4.2 I/O多路复用这里对比传统的阻塞I/O来简单介绍下I/O多路复用 4.2.1 阻塞IO模型进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。 1、典型应用：阻塞socket、Java BIO； 2、特点：进程阻塞挂起不消耗CPU资源，及时响应每个操作；实现难度低、开发应用较容易；适用并发量小的网络应用开发； 不适用并发量大的应用：因为一个请求IO会阻塞进程，所以，得为每请求分配一个处理进程（线程）以及时响应，系统开销大。 4.2.2 IO复用模型 多个的进程的IO可以注册到一个复用器（select）上，然后用一个进程调用该select， select会监听所有注册进来的IO；如果select没有监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，select调用就会返回；而后select调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据。可以看到，多个进程注册IO后，只有另一个select调用进程被阻塞。 1、典型应用：select、poll、epoll三种方案，nginx都可以选择使用这三个方案;Java NIO; 2、特点：专一进程解决多个进程IO的阻塞问题，性能好；Reactor模式;实现、开发应用难度较大；适用高并发服务应用开发：一个进程（线程）响应多个请求； 5. Redis过期数据清除官方文档 与 《Redis设计与实现》中的详述，过期数据的清除从来不容易，为每一条key设置一个timer，到点立刻删除的消耗太大，每秒遍历所有数据消耗也大，Redis使用了一种相对务实的做法： 当client主动访问key会先对key进行超时判断，过时的key会立刻删除。 如果client永远都不再get那条key呢？ 它会在Master的后台，每秒10次的执行如下操作： 随机选取100个key校验是否过期，如果有25个以上的key过期了，立刻额外随机选取下100个key(不计算在10次之内)。 可见，如果过期的key不多，它最多每秒回收200条左右，如果有超过25%的key过期了，它就会做得更多，但只要key不被主动get，它占用的内存什么时候最终被清理掉只有天知道。 6. Redis的持久化机制对于persistence持久化存储，Redis提供了两种持久化方法： Redis DataBase(简称RDB) Append-only file (简称AOF) 除了这两种方法，Redis在早起的版本还存在虚拟内存的方法，现在已经被废弃。 6.1 RDB概述RDB是在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。 优点：使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能 缺点：RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候 这里说的这个执行数据写入到临时文件的时间点是可以通过配置来自己确定的，通过配置redis在n秒内如果超过m个key被修改这执行一次RDB操作。这个操作就类似于在这个时间点来保存一次Redis的所有数据，一次快照数据。所有这个持久化方法也通常叫做snapshots。 6.2 AOF概述Append-only file，将“操作 + 数据”以格式化指令的方式追加到操作日志文件的尾部，在append操作返回后(已经写入到文件或者即将写入)，才进行实际的数据变更，“日志文件”保存了历史所有的操作过程；当server需要数据恢复时，可以直接replay此日志文件，即可还原所有的操作过程。AOF相对可靠，它和mysql中bin.log、apache.log、zookeeper中txn-log简直异曲同工。AOF文件内容是字符串，非常容易阅读和解析。 优点：可以保持更高的数据完整性，如果设置追加file的时间是1s，如果redis发生故障，最多会丢失1s的数据；且如果日志写入不完整支持redis-check-aof来进行日志修复；AOF文件没被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的flushall）。 缺点：AOF文件比RDB文件大，且恢复速度慢。 我们可以简单的认为AOF就是日志文件，此文件只会记录“变更操作”(例如：set/del等)，如果server中持续的大量变更操作，将会导致AOF文件非常的庞大，意味着server失效后，数据恢复的过程将会很长；事实上，一条数据经过多次变更，将会产生多条AOF记录，其实只要保存当前的状态，历史的操作记录是可以抛弃的；因为AOF持久化模式还伴生了“AOF rewrite”。 AOF的特性决定了它相对比较安全，如果你期望数据更少的丢失，那么可以采用AOF模式。如果AOF文件正在被写入时突然server失效，有可能导致文件的最后一次记录是不完整，你可以通过手工或者程序的方式去检测并修正不完整的记录，以便通过aof文件恢复能够正常；同时需要提醒，如果你的redis持久化手段中有aof，那么在server故障失效后再次启动前，需要检测aof文件的完整性。 AOF默认关闭。 该笔记参考了以下文章： 超强、超详细Redis入门教程 - CSDN博客 Redis 5种数据结构使用及注意事项 - 孟凡柱的专栏 - 博客园 Redis系列—-(二)redis中的数据结构类型 - CSDN博客 Redis常用数据结构和操作 - WhoAmMe - 博客园 5种IO模型、阻塞IO和非阻塞IO、同步IO和异步IO - CSDN博客 redis是个单线程的程序，为什么会这么快呢？ - 知乎 Redis为什么使用单进程单线程方式也这么快 - CSDN博客 Redis持久化存储(AOF与RDB两种模式)_数据库技术_Linux公社-Linux系统门户网站 参考网站： Redis 教程 | 菜鸟教程 Redis_百度百科 Copyright © 2018, GDUT CSCW back-end Kanarien, All Rights Reserved","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Kanarienvogels.github.io/categories/学习笔记/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://Kanarienvogels.github.io/tags/Redis/"}]}]}