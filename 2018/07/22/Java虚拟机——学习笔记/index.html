<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Kanarien" />



<meta name="description" content="0. 前言Java 作为一门面向对象的语言被广泛的使用，知名企业中大量使用Java的有Amazon，Linkedin，阿里，美团，搜狐；用的比较少的知名企业有百度，腾讯等，可以说凡是大企业都或多或少的有用到Java。一些被广泛使用的开源系统、框架也完全使用Java进行编写，比如Android操作系统和Hadoop分布式系统基础框架。为什么Java会收到欢迎？除了其本身面向对象的特性极大的加快了开发">
<meta name="keywords" content="Java,JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="Java虚拟机——学习笔记">
<meta property="og:url" content="http://Kanarienvogels.github.io/2018/07/22/Java虚拟机——学习笔记/index.html">
<meta property="og:site_name" content="无悔的博客小屋">
<meta property="og:description" content="0. 前言Java 作为一门面向对象的语言被广泛的使用，知名企业中大量使用Java的有Amazon，Linkedin，阿里，美团，搜狐；用的比较少的知名企业有百度，腾讯等，可以说凡是大企业都或多或少的有用到Java。一些被广泛使用的开源系统、框架也完全使用Java进行编写，比如Android操作系统和Hadoop分布式系统基础框架。为什么Java会收到欢迎？除了其本身面向对象的特性极大的加快了开发">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/316892/201601/316892-20160107185655528-480221492.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/316892/201601/316892-20160107184612653-1541384173.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/316892/201601/316892-20160107184347684-1132906737.png">
<meta property="og:image" content="http://note.youdao.com/yws/api/personal/file/6A4B4E6C96FF44A7A912EB9A941A0836?method=download&shareKey=8e920258db28419793990a180020b75c">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.JPG">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/908514/201607/908514-20160728195713028-1922699910.jpg">
<meta property="og:image" content="http://static.zybuluo.com/Rico123/q0t6nxkafapyn6yql7benc32/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg">
<meta property="og:image" content="http://static.zybuluo.com/Rico123/vmdnj50kic23uptbswo9dqnw/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.jpg">
<meta property="og:image" content="http://static.zybuluo.com/Rico123/mkqv5cf4vg8v72wvxtz0abwz/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95">
<meta property="og:image" content="http://static.zybuluo.com/Rico123/0gzyeoiz3mf7n20jitv2g2aw/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95">
<meta property="og:image" content="http://static.zybuluo.com/Rico123/yn5j5ojk6mz9axjutk4hogxq/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%951.jpg">
<meta property="og:image" content="http://static.zybuluo.com/Rico123/b26me40cjhiqkeb2vl6jb807/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<meta property="og:image" content="http://static.zybuluo.com/Rico123/9hswys8w1pqy0ch06vmlbqi2/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E8%AF%AD%E8%A8%80%E6%97%A0%E5%85%B3%E6%80%A7.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E5%B8%B8%E9%87%8F%E6%B1%A0%E9%A1%B9%E7%9B%AE%E7%B1%BB%E5%9E%8B.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E5%AD%97%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%BB%93%E6%9E%84.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E6%96%B9%E6%B3%95%E8%A1%A8%E9%9B%86%E5%90%88.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E5%B1%9E%E6%80%A7%E8%A1%A8%E7%BB%93%E6%9E%84.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B1%9E%E6%80%A7%281%29.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B1%9E%E6%80%A7%282%29.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B1%9E%E6%80%A7%283%29.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B1%9E%E6%80%A7%284%29.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/Code%E5%B1%9E%E6%80%A7%E8%A1%A8%E7%BB%93%E6%9E%84.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E5%BC%82%E5%B8%B8%E8%A1%A8%E7%BB%93%E6%9E%84.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/Sun%20Javac%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/Sun%20Javac%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%B8%BB%E4%BD%93%E4%BB%A3%E7%A0%81.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E7%9A%84%E4%BE%8B%E5%AD%90.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E7%9A%84%E4%BE%8B%E5%AD%902.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A6%E5%8F%91%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91.JPG">
<meta property="og:image" content="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/Client%20Compiler%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.JPG">
<meta property="og:updated_time" content="2018-07-22T12:54:24.717Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java虚拟机——学习笔记">
<meta name="twitter:description" content="0. 前言Java 作为一门面向对象的语言被广泛的使用，知名企业中大量使用Java的有Amazon，Linkedin，阿里，美团，搜狐；用的比较少的知名企业有百度，腾讯等，可以说凡是大企业都或多或少的有用到Java。一些被广泛使用的开源系统、框架也完全使用Java进行编写，比如Android操作系统和Hadoop分布式系统基础框架。为什么Java会收到欢迎？除了其本身面向对象的特性极大的加快了开发">
<meta name="twitter:image" content="http://images2015.cnblogs.com/blog/316892/201601/316892-20160107185655528-480221492.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="无悔的博客小屋" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Java虚拟机——学习笔记 | 无悔的博客小屋</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Kanarien</a></h1>
        </hgroup>

        
        <p class="header-subtitle">协同快乐与伤悲</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:&#75;&#97;&#110;&#97;&#114;&#105;&#101;&#110;&#118;&#111;&#103;&#101;&#108;&#115;&#64;&#49;&#50;&#54;&#46;&#99;&#111;&#109;" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/Kanarienvogels" title="GitHub"></a>
                            
                                <a class="fa SegmentFault" href="https://segmentfault.com/u/kanarien" title="SegmentFault"></a>
                            
                                <a class="fa 网易云音乐" href="https://music.163.com/#/user/home?id=493613324" title="网易云音乐"></a>
                            
                                <a class="fa bilibili" href="https://space.bilibili.com/44792275/#/" title="bilibili"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/">Netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/">Nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/">WebSocket</a></li></ul>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">Java后端开发，欢迎大家来讨论Java、Linux、Mysql、Redis等相关的知识</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Kanarien</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Kanarien</a></h1>
            </hgroup>
            
            <p class="header-subtitle">协同快乐与伤悲</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:&#75;&#97;&#110;&#97;&#114;&#105;&#101;&#110;&#118;&#111;&#103;&#101;&#108;&#115;&#64;&#49;&#50;&#54;&#46;&#99;&#111;&#109;" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/Kanarienvogels" title="GitHub"></a>
                            
                                <a class="fa SegmentFault" target="_blank" href="https://segmentfault.com/u/kanarien" title="SegmentFault"></a>
                            
                                <a class="fa 网易云音乐" target="_blank" href="https://music.163.com/#/user/home?id=493613324" title="网易云音乐"></a>
                            
                                <a class="fa bilibili" target="_blank" href="https://space.bilibili.com/44792275/#/" title="bilibili"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-Java虚拟机——学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/22/Java虚拟机——学习笔记/" class="article-date">
      <time datetime="2018-07-22T12:49:43.268Z" itemprop="datePublished">2018-07-22</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java虚拟机——学习笔记
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/学习笔记/">学习笔记</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2><span id="0-前言">0. 前言</span></h2><p>Java 作为一门面向对象的语言被广泛的使用，知名企业中<strong>大量使用Java</strong>的有<strong>Amazon，Linkedin，阿里，美团，搜狐</strong>；<strong>用的比较少</strong>的知名企业有<strong>百度，腾讯</strong>等，可以说凡是大企业都或多或少的有用到Java。一些被广泛使用的开源系统、框架也完全使用Java进行编写，比如<strong>Android操作系统</strong>和<strong>Hadoop分布式系统基础框架</strong>。为什么Java会收到欢迎？除了其本身<strong>面向对象的特性</strong>极大的加快了开发效率这个表面原因，另一个重要的原因就是Java 虚拟机 (Java Virtual Machine)的存在，为程序<strong>提供了一个稳定健壮的运行环境</strong>。<br><a id="more"></a></p>
<p>Kanarien：<br>其实我们Java程序员每天都用Java写程序，却很少有人会去了解这门语言的内在，毕竟重于计算机是一门实践性科学(<del>整天敲代码</del>)。应该找个空闲的时间来了解一下Java的底层架构，毕竟计算机科学同时也是一门理论性的学科(<del>一堆的专业书</del>)，是时候向<strong>Java高级方面</strong>迈进了！嘛，其实本人之所以会想了解JVM，原因还在于<strong>Java虚拟机与Java并发编程同时也是当今大数据时代的基础知识</strong>，是很重要的底层知识，顺应时代的潮流，我们有这个必要性去了解。</p>
<p>该文章结合了本人所学的知识，并参考了以下文章：</p>
<ul>
<li><a href="http://blog.csdn.net/yano_nankai/article/details/50957578" target="_blank" rel="noopener">Java 虚拟机面试题全面解析（干货） - CSDN博客</a></li>
<li><a href="https://www.cnblogs.com/lao-liang/p/5110710.html" target="_blank" rel="noopener">理解Java虚拟机体系结构 - LeoLiang - 博客园</a></li>
<li><a href="https://www.cnblogs.com/SaraMoring/p/5713732.html" target="_blank" rel="noopener">JVM内存堆布局图解分析 - Sara早安 - 博客园</a></li>
<li><a href="http://blog.csdn.net/zsuguangh/article/details/6429592" target="_blank" rel="noopener">Java垃圾回收机制 - CSDN博客</a></li>
<li><a href="http://blog.csdn.net/plgy_Y/article/details/72791483" target="_blank" rel="noopener">图解Java 垃圾回收机制 - CSDN博客</a></li>
</ul>
<p>该文章也借阅了书籍《深入理解Java虚拟机》，这里提供个人的pdf下载地址：<a href="http://myftp-1254133416.cosgz.myqcloud.com/pdf/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%88%E6%9C%80%E6%96%B0%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89.pdf" target="_blank" rel="noopener">《深入理解Java虚拟机》</a></p>
<hr>
<p><strong>目录</strong></p>
<!-- toc -->
<ul>
<li><a href="#1-java-虚拟机概述">1. Java 虚拟机概述</a><ul>
<li><a href="#11-任务概述">1.1 任务概述</a></li>
<li><a href="#12-功能概述">1.2 功能概述</a></li>
<li><a href="#13-java-虚拟机的生命周期">1.3 Java 虚拟机的生命周期</a></li>
<li><a href="#14-java-虚拟机与java-程序">1.4 Java 虚拟机与Java 程序</a></li>
<li><a href="#15-虚拟机与物理机">1.5 虚拟机与物理机</a></li>
</ul>
</li>
<li><a href="#2-jvm内存结构与对象">2. JVM内存结构与对象</a><ul>
<li><a href="#21-数据运行时区域">2.1 数据运行时区域</a></li>
<li><a href="#22-对象的创建">2.2 对象的创建</a></li>
<li><a href="#23-对象的内存布局">2.3 对象的内存布局</a></li>
<li><a href="#24-对象的访问">2.4 对象的访问</a></li>
</ul>
</li>
<li><a href="#3-类加载相关">3. 类加载相关</a><ul>
<li><a href="#31-类装载器子系统">3.1 类装载器子系统</a></li>
<li><a href="#32-类加载机制">3.2 类加载机制</a></li>
</ul>
</li>
<li><a href="#4-垃圾回收机制">4. 垃圾回收机制</a><ul>
<li><a href="#41-垃圾回收概述">4.1 垃圾回收概述</a></li>
<li><a href="#42-垃圾回收意义">4.2 垃圾回收意义</a></li>
<li><a href="#43-垃圾回收区域">4.3 垃圾回收区域</a></li>
<li><a href="#44-垃圾回收种类">4.4 垃圾回收种类</a></li>
<li><a href="#45-垃圾回收时机">4.5 垃圾回收时机</a></li>
<li><a href="#46-垃圾回收对象">4.6 垃圾回收对象</a></li>
<li><a href="#47-垃圾回收算法">4.7 垃圾回收算法</a></li>
<li><a href="#48-垃圾回收器">4.8 垃圾回收器</a></li>
</ul>
</li>
<li><a href="#5-class文件">5. Class文件</a><ul>
<li><a href="#51-无关性">5.1 无关性</a></li>
<li><a href="#52-class文件内容解析">5.2 Class文件内容解析</a></li>
<li><a href="#53-字节码指令">5.3 字节码指令</a></li>
<li><a href="#54-java虚拟机的实现方式">5.4 Java虚拟机的实现方式</a></li>
</ul>
</li>
<li><a href="#6-字节码执行引擎">6. 字节码执行引擎</a><ul>
<li><a href="#61-栈帧">6.1 栈帧</a></li>
<li><a href="#62-方法调用">6.2 方法调用</a></li>
<li><a href="#63-解释执行">6.3 解释执行</a></li>
</ul>
</li>
<li><a href="#7-编译期优化">7. 编译期优化</a><ul>
<li><a href="#71-sun-javac-编译过程">7.1 Sun Javac 编译过程</a></li>
<li><a href="#72-java语法糖糖衣背后的真实">7.2 Java语法糖——糖衣背后的真实</a></li>
</ul>
</li>
<li><a href="#8-运行期优化">8. 运行期优化</a><ul>
<li><a href="#81-jit编译器">8.1 JIT编译器</a></li>
<li><a href="#82-解释器与编译器">8.2 解释器与编译器</a></li>
<li><a href="#83-编译对象与触发条件">8.3 编译对象与触发条件</a></li>
<li><a href="#84-编译过程">8.4 编译过程</a></li>
<li><a href="#85-编译技术">8.5 编译技术</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="1-java-虚拟机概述">1. Java 虚拟机概述</span></h2><h3><span id="11-任务概述">1.1 任务概述</span></h3><p><strong>Java 虚拟机的主要任务是装载class文件并且执行其中的字节码</strong>。由下图可以看出，Java虚拟机包含一个类装载器（class loader），它可以从程序和API中装载class文件，Java API中只有程序执行时需要的类才会被装载，字节码由执行引擎来执行。</p>
<p><img src="http://images2015.cnblogs.com/blog/316892/201601/316892-20160107185655528-480221492.png" alt="Java 虚拟机的主要任务"></p>
<p>当Java虚拟机由主机操作系统上的软件实现时，Java程序通过调用本地方法和主机进行交互。<strong>Java方法由Java语言编写，编译成字节码，存储在class文件中</strong>。<strong>本地方法由C/C++/汇编语言编写</strong>，编译成和处理器相关的机器代码，存储在动态链接库中，格式是各个平台专有。所以<strong>本地方法是联系Java程序和底层主机操作系统的连接方式</strong>。</p>
<p>　　由于<strong>Java虚拟机并不知道某个class文件是如何被创建的，是否被篡改一无所知</strong>，所以它实现了一个class文件检测器，确保class文件中定义的类型可以安全地使用。class文件检验器通过<strong>四趟独立的扫描</strong>来<strong>保证程序的健壮性</strong>：(详细见3.2.2类加载——连接之验证)</p>
<ul>
<li>class文件的结构检查</li>
<li>类型数据的语义检查</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>
<p>　　Java 虚拟机在执行字节码时还进行其它的一些<strong>内置的安全机制的操作</strong>，他们作为Java编程语言保证Java 程序健壮性的特性，同时也是Java虚拟机的特性：</p>
<ul>
<li>类型安全的引用转换</li>
<li><strong>结构化的内存访问</strong></li>
<li><strong>自动垃圾收集</strong></li>
<li>数组边界检查</li>
<li>空引用检查</li>
</ul>
<h3><span id="12-功能概述">1.2 功能概述</span></h3><blockquote>
<p>write once, run anywhere  一次编译， 到处运行</p>
</blockquote>
<p>虚拟机是一种<strong>抽象化的计算机</strong>，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。<strong>Java虚拟机屏蔽了与具体操作系统平台相关的信息</strong>，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。正是得益于Java虚拟机，它号称的“一次编译，到处运行”才能有所保障。</p>
<h3><span id="13-java-虚拟机的生命周期">1.3 Java 虚拟机的生命周期</span></h3><p><strong>启动一个Java程序时，一个虚拟机实例也就诞生了</strong>。当该程序关闭退出，这个虚拟机实例也就随之消亡。如果同一台计算机上同时运行三个Java程序，将得到三个Java虚拟机实例。<strong>每个Java程序都运行于它自己的Java虚拟机实例中</strong>。</p>
<p>Java虚拟机实例通过调用某个初始类的main()方法来运行一个Java程序。而这个main()方法必须是共有的(public)、静态的(static)、返回值为void，并且接受一个字符串数组作为参数。任何拥有这样一个main()方法的类都可以作为Java程序运行的起点。</p>
<p>在以下几种情况下,Java 虚拟机将<strong>结束生命周期</strong>。</p>
<ol>
<li>执行了<strong>System.exit</strong>()方法<br>通过查看api文档,我们exit的参数为int,当参数为0就是正常结束,否则就是非正常结束。</li>
<li><strong>程序正常结束</strong></li>
<li>程序执行过程中遇到<strong>异常或错误</strong></li>
<li><strong>操作系统出现错误</strong></li>
</ol>
<h3><span id="14-java-虚拟机与java-程序">1.4 Java 虚拟机与Java 程序</span></h3><p>Java程序的执行依赖于编译环境和运行环境。源码代码转变成可执行的机器代码，由下面的流程完成：</p>
<p><img src="http://images2015.cnblogs.com/blog/316892/201601/316892-20160107184612653-1541384173.png" alt="Java程序编译与运行的执行流程"></p>
<p><strong>Java技术的核心就是Java虚拟机</strong>，因为所有的Java程序都在虚拟机上运行。Java程序的运行需要Java虚拟机、Java API和Java Class文件的配合。Java虚拟机实例负责运行一个Java程序。<strong>当启动一个Java程序时，一个虚拟机实例就诞生了。当程序结束，这个虚拟机实例也就消亡</strong>。</p>
<p><img src="http://images2015.cnblogs.com/blog/316892/201601/316892-20160107184347684-1132906737.png" alt="Java虚拟机实例"></p>
<p>Java的跨平台特性，因为它有针对不同平台的虚拟机。</p>
<h3><span id="15-虚拟机与物理机">1.5 虚拟机与物理机</span></h3><p>虚拟机是一个相对于物理机的概念，两种机器都具有执行代码的能力。区别在于物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统上的，而虚拟机的执行引擎是自己实现的，可自行定义指令集与执行引擎的结构体系。</p>
<hr>
<h2><span id="2-jvm内存结构与对象">2. JVM内存结构与对象</span></h2><h3><span id="21-数据运行时区域">2.1 数据运行时区域</span></h3><p>虚拟机的结构都是在内存中的一块空间，称为<strong>虚拟机内存结构</strong>，也称为<strong>数据运行时区域</strong>。</p>
<p>虚拟机的内存结构由<strong>五部分</strong>组成:</p>
<ol>
<li>程序计数器</li>
<li>Java 虚拟机栈</li>
<li>本地方法栈</li>
<li>Java 堆</li>
<li>方法区</li>
</ol>
<p><img src="http://note.youdao.com/yws/api/personal/file/6A4B4E6C96FF44A7A912EB9A941A0836?method=download&amp;shareKey=8e920258db28419793990a180020b75c" alt=""></p>
<h4><span id="211-程序计数器">2.1.1 程序计数器</span></h4><p>程序计数器（Program Counter Register）是一块较小的内存空间，可以看作是<strong>当前线程所执行字节码的行号指示器</strong>。<strong>分支、循环、跳转、异常处理、线程恢复</strong>等基础功能都需要依赖这个计数器完成。</p>
<p>由于 Java 虚拟机的多线程是通过<strong>线程轮流切换</strong>并分配处理器执行时间的方式实现的。<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各线程之间的计数器互不影响，独立存储。</strong></p>
<ul>
<li><p>如果线程正在执行的是一个 Java 方法，计数器记录的是正在执行的虚拟机字节码指令的地址；</p>
</li>
<li><p>如果正在执行的是 本地 方法，这个计数器的值为空。</p>
</li>
</ul>
<p><strong>程序计数器是唯一一个没有规定任何 内存溢出(OutOfMemoryError) 的区域。</strong></p>
<h4><span id="212-java虚拟机栈">2.1.2 Java虚拟机栈</span></h4><p>Java 虚拟机栈（Java Virtual Machine Stacks）是线程私有的，生命周期与线程相同。<br>虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧（Stack Frame），存储</p>
<ol>
<li><p>局部变量表</p>
</li>
<li><p>操作栈</p>
</li>
<li><p>动态链接</p>
</li>
<li><p>方法出口</p>
</li>
</ol>
<p>每一个方法被调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>这个区域有两种异常情况：</p>
<ol>
<li><p>StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度</p>
</li>
<li><p>OutOfMemoryError：虚拟机栈扩展到无法申请足够的内存时</p>
</li>
</ol>
<blockquote>
<p>当程序在运行时抛出异常时，进行捕获时，经常会用到<strong>e.printStackTrace()</strong>,其输出的异常信息就是按对应线程的Java 虚拟机栈出栈输出的。</p>
</blockquote>
<h4><span id="213-本地方法栈">2.1.3 本地方法栈</span></h4><p>本地方法栈（Native Method Stacks）为<strong>虚拟机使用到的 本地(Native) 方法服务</strong>，是线程私有的。其<strong>与Java虚拟机栈类似</strong>，只不过Java 虚拟机栈为的是Java方法（字节码）服务 。不过，在虚拟机规范中，本地方法栈使用的语言、方式、数据结构没有绝对的规定，任何具体的虚拟机都可以自由实现。</p>
<h4><span id="214-java-堆">2.1.4 Java 堆</span></h4><p>Java 堆（Java Heap）是 Java 虚拟机中<strong>内存最大的一块</strong>。Java 堆在虚拟机<strong>启动时创建</strong>，被所有<strong>线程共享</strong>。</p>
<ul>
<li>作用：<strong>存放对象实例</strong>，也是<strong>唯一</strong>的目的。</li>
<li><strong>垃圾收集器</strong>主要管理的就是 Java 堆。</li>
<li>Java 堆在物理上可以不连续，只要<strong>逻辑上连续</strong>即可。</li>
</ul>
<h4><span id="215-方法区">2.1.5 方法区</span></h4><p>方法区（Method Area）被所有<strong>线程共享</strong>，用于存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。方法区也被叫做永久代，在Java堆之外，JDK8中已把方法区（永久代）移除，取而代之的是原数据区(Meta Space)</p>
<p>和 Java 堆一样，不需要连续的内存，可以选择固定的大小，更可以选择不实现垃圾收集。</p>
<h4><span id="216-运行时常量池">2.1.6 运行时常量池</span></h4><p>运行时常量池（Runtime Constant Pool）是<strong>方法区的一部分</strong>。保存 <strong>Class 文件中的符号引用、翻译出来的直接引用</strong>。运行时常量池可以在运行期间将新的常量放入池中。</p>
<h4><span id="217-直接内存">2.1.7 直接内存</span></h4><p>直接内存（Direct Memory）并<strong>不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域</strong>，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现，所以我们放到这里一起讲解。</p>
<p>在JDK 1.4 中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O 方式，<strong>它可以使用Native 函数库直接分配堆外内存</strong>，然后通过一个存储在Java 堆里面的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为<strong>避免了在Java 堆和Native 堆中来回复制数据</strong>。显然，<strong>本机直接内存的分配不会受到Java 堆大小的限制</strong>，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM 及SWAP 区或者分页文件）的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p>
<h3><span id="22-对象的创建">2.2 对象的创建</span></h3><p>new指令 =&gt; 类加载 =&gt; 内存分配 =&gt; 内存初始化 =&gt; 对象头设置 =&gt; 构造方法执行</p>
<h4><span id="221-类加载">2.2.1 类加载</span></h4><p>虚拟机遇到一个new指令时，首先会去检查这个指令的参数能否在常量池定位到一个符号引用，并检查这个符号引用代表的类是否已被加载、解析、初始化过，如果没有则进行类加载过程(见模块3)。</p>
<h4><span id="222-内存分配">2.2.2 内存分配</span></h4><p>类加载通过后，为对象分配内存，对象所占的内存大小由类加载可完全确定。内存分配方式有两种：指针碰撞和空闲列表。</p>
<p>指针碰撞：若内存是绝对规整的，所有用过的内存在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，分配内存的动作即为指针向空闲空间那边挪动一小段与对象大小相等的距离。</p>
<p>空闲列表：若内存不是规整的，已使用的内存和空闲的内存相互交错，虚拟机通过一个列表记录内存的使用状况，分配内存时从列表中找出一块足够大的空间给对象实例并更新记录。</p>
<p>选择哪种分配方式由Java堆内存是否规整决定，而Java堆内存是否规整由所采用的垃圾收集器决定<br>。使用Serial、ParNew等Compact过程的收集器，采用指针碰撞；使用CMS收集器等基于标记清除算法的收集器则采用空闲列表。</p>
<p>分配内存也要考虑到对象频繁创建时出现的线程安全问题。</p>
<h4><span id="223-内存初始化">2.2.3 内存初始化</span></h4><p>内存分配完毕后，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。保证对象的实例字段不赋初值就能够被访问到数据类型对应的零值。</p>
<h4><span id="224-对象头设置">2.2.4 对象头设置</span></h4><p>对对象进行必要的设置，比如：该对象是哪个类的实例、如何找到这个类的元信息、对象的哈希码、GC分代信息。这些信息都放置在对象头中。</p>
<h4><span id="225-构造函数执行">2.2.5 构造函数执行</span></h4><p>以上操作完成后，从虚拟机角度来看，对象的创建已经完成了，但从Java程序的角度来讲，对象的创建才开始（虚拟机对上屏蔽了对象内存分配的细节），程序员通过执行构造函数来进行对象的初始化。</p>
<h3><span id="23-对象的内存布局">2.3 对象的内存布局</span></h3><p>对象在内存中的存储布局可分为3块：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）。</p>
<p>对象头（Header）：对象头包括两部分信息，一是对象自身运行时的数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。另一部分是类型指针，即对象指向它类元数据的指针，虚拟机通过这确定对象是哪个类的实例。</p>
<p>实例数据（Instance Data）：对象真正存储的有效信息，也是程序代码中定义的各种类型的字段内容。无论是父类的还是子类的数据都要记录。</p>
<p>对齐填充（Padding）：仅起着占位符的作用。对象起始地址必须是8字节的整数倍，对象头肯定是8字节的整数倍，而实例数据则不一定，此时用对齐填充来补全。</p>
<h3><span id="24-对象的访问">2.4 对象的访问</span></h3><p>程序中通过操作reference（引用）来操作对象，在Java堆内存中，对象的访问分为两种方式：句柄访问和直接访问。</p>
<p><strong>句柄访问</strong>：Java堆中划分出一块内存作为句柄池，reference（引用）中存储的是对象的句柄地址，句柄包括了对象实例数据的地址和对象类型数据的地址。<br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.JPG" alt="句柄访问"></p>
<p><strong>直接指针访问</strong>：<br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.JPG" alt="直接指针访问"></p>
<p>使用句柄访问的好处是reference中存储的是稳定的句柄地址，对象被移动（如GC）只会改变实例数据指针的值，而不用reference本身的值。使用直接指针访问最大的好处是速度快。Hot Spot虚拟机采用的是直接指针访问</p>
<hr>
<h2><span id="3-类加载相关">3. 类加载相关</span></h2><h3><span id="31-类装载器子系统">3.1 类装载器子系统</span></h3><p>类装载器子系统负责查找并装载类型信息。其实Java虚拟机有<strong>两种类装载器</strong>：</p>
<ol>
<li>系统装载器</li>
<li>用户自定义装载器</li>
</ol>
<p><strong>前者是Java虚拟机实现的一部分，后者则是Java程序的一部分。</strong></p>
<h4><span id="311-系统装载器">3.1.1 系统装载器</span></h4><p>Java 系统装载器主要有3种：</p>
<ol>
<li>启动类装载器（bootstrap class loader）：也叫根装载器。它用来<strong>加载 Java 的核心库</strong>，是用原生代码（HotSpot 虚拟机使用C++）来实现的，并不继承自java.lang.ClassLoader。负责将存放在\lib目录中的类库加载到虚拟机中。其<strong>无法被Java程序直接引用，无法直接获取</strong>。</li>
<li>扩展类装载器（extensions class loader）：是<strong>启动类装载器的子类</strong>。它用来加载 <strong>Java 的扩展库</strong>。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类,即负责加载\lib\ext目录中的所有类库，<strong>开发者可以直接使用</strong>。</li>
<li>应用程序类加载器（Application ClassLoader）：是<strong>扩展类装载器的子类</strong>。它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。<strong>默认情况下，Java 应用的类都是由它来完成加载的</strong>。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li>
</ol>
<blockquote>
<p><strong>名词解释 —— HotSpot 虚拟机</strong><br>SunJDK和OpenJDK中自带的虚拟机，也是最被广泛使用的虚拟机。</p>
</blockquote>
<blockquote>
<p>一般说的启动类装载器加载器使用C++语言实现。这里<strong>只限于HotSpot</strong>,像MRP, Maxine等虚拟机, 整个虚拟机本身都是由Java编写的, 自然BootstrapClassLoader 也是由Java语言而不是C++实现的, 退一步讲, 除了HotSpot以外的其他两个高性能虚拟机JRockit和J9都有一个代表BootstrapClassLoader的java类存在, 但是关键方法的实现仍然是使用JNI回调到C, 不是C++的实现上, 这个BootstrapClassLoader的实例也无法被用户获取到。</p>
</blockquote>
<h4><span id="312-用户自定义类装载器">3.1.2 用户自定义类装载器</span></h4><p>开发人员可以通过<strong>继承 java.lang.ClassLoader类</strong>的方式实现自己的类装载器，以满足一些特殊的需求。</p>
<h4><span id="313-双亲委派模型">3.1.3 双亲委派模型</span></h4><p>我们的应用程序都是由4.1.1中的3种类加载器互相配合进行加载的, 如果有必要, 还可以加入自己定义的类加载器. 这些<strong>类加载器之间的关系</strong>是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">  boot(启动类装载器 bootstrap class loader) --&gt; ext(扩展类装载器 extensions class loader)</span><br><span class="line">  ext --&gt; app(应用程序类加载器 Application ClassLoader)</span><br><span class="line">  app --&gt; user1(用户自定义类加载器 User ClassLoader)</span><br><span class="line">  app --&gt; user2(用户自定义类加载器 User ClassLoader)</span><br></pre></td></tr></table></figure></p>
<p>双亲委派模型要求除了顶层的启动类加载器外,其余的类加载器都应当有自己的父类加载器. 这里类加载器之间的父子关系<strong>一般不会以继承(Inheritance)的关系来实现, 而是都使用组合(Composition)关系</strong>来复用父加载器的代码。</p>
<p>类加载器的双亲委派模型在JDK1.2期间被引入并被广泛应用于之后几乎所有的java程序中,但它<strong>并非不是一个强制性的约束模型</strong>,而是java设计者推荐给开发者的一种类加载器实现方式.</p>
<p><strong>双亲委派模型的工作过程</strong>是 :<br>如果一个类加载器收到了类加载的请求,它<strong>首先不会自己去尝试加载这个类, 而是把这个请求委派给父类加载器去完成, 每一个层次的类加载器都是如此</strong>, 因此所有的加载请求最都应该传送到顶层的启动类加载器中, <strong>只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围内没有找到所需的类)时, 子加载器才会尝试自己去加载</strong>。</p>
<p><strong>使用双亲委派模型的好处</strong>：</p>
<ul>
<li>java类随着它的类加载器一起具备了一种<strong>带有优先级的层次关系</strong>. 例如类Java.lang.Object,它存放在rt.jar之中, 无论哪一个类加载器要加载这个类, 最终都是委派给处于模型最顶端的启动类加载器进行加载, 由各个类加载器自行去加载的话,如果用户自己编写了一个称为java.lang.Object的类,并放在程序的classpath中,那系统中将会出现多个不同的Object类, java类型体系中最基础的行为也就无法保证, 应用程序也将会变得一片混乱。</li>
<li><strong>实现非常简单</strong>,实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass()方法之中, 逻辑清晰。</li>
<li><strong>从安全上考虑，有利于防止第三方往JVM中装载恶意的基础类</strong>。比如一个恶意的java.lang.String，由于双亲委派机制，基础类java.lang.String就会被往上请求加载，使用启动类装载器进行装载，从而避免恶意事件发生。</li>
</ul>
<h3><span id="32-类加载机制">3.2 类加载机制</span></h3><p><strong>Class文件描述的各种信息，都需要加载到虚拟机后才能运行</strong>。虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，<strong>最终形成可以被虚拟机直接使用的Java类型</strong>，这就是虚拟机的类加载机制。</p>
<p>在Java中类装载器把一个类装入JVM，有以下步骤：</p>
<ol>
<li><strong>加载</strong>: 查找并加载类的二进制数据</li>
<li><strong>连接</strong>:<ul>
<li><strong>验证</strong> 确保被加载的类的正确性</li>
<li><strong>准备</strong> 为类的静态变量分配内存,并将其初始化为默认值(int就是0 boolean就是       false 引用类型就是null)</li>
<li><strong>解析</strong> 把类中的符号引用变为直接引用</li>
</ul>
</li>
<li><strong>初始化</strong>: 为类的静态变量赋予正确的初始值，只有在初始化阶段,赋值的=才发挥作用，且从上往下顺序执行。</li>
</ol>
<p>理解起来应该没什么问题，那么</p>
<p>提问：在我们最开始编写java的时候总是javac命令编译成class字节码,java命令运行。如果java代码有什么问题,在javac的时候就会抛出问题,换句话说等我们连接class文件的时候它肯定是没问题的,那还验证什么呢？</p>
<p>答案：如果class的产生只能通过javac命令的话,那就没有任何问题了,可关键就是人们也可以手动产生class文件,所以验证这一步还是有用的。</p>
<h4><span id="321-加载">3.2.1 加载</span></h4><p>类的加载指的是通过一个类的全限定名来获取定义此类的二进制字节流，最一般的情况是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在Java 堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。也可以通过ZIP、JAR、WAR、网络(Applet)、JSP、或动态代理技术读取。</p>
<p><strong>类的加载的最终产品是位于Java 堆区中的Class对象</strong></p>
<blockquote>
<p><strong>名词解释 —— Class对象:</strong><br>每个类也都有一个描述自己信息的东西,它就是Class对象。这个类的Class对象里就包含了这个类里面有几个属性,每个属性是什么类型,有什么方法,每个方法的参数都是什么,返回值都是什么等等。<br>如果有使用过反射类java.lang.Reflect中的对象与接口，对此应该不陌生。具体信息,参考JDK文档。</p>
</blockquote>
<h4><span id="322-连接之验证">3.2.2 连接之验证</span></h4><p>这一阶段的目的是<strong>为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</strong>。</p>
<p>验证阶段大致会完成4个阶段的检验动作：</p>
<ol>
<li><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范；例如：是否以魔数0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li><strong>元数据验证</strong>：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外；是否继承了不允许继承的类（被final修饰的类）。</li>
<li><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li><strong>符号引用验证</strong>：确保解析动作能正确执行。<br>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</li>
</ol>
<h4><span id="323-连接之准备">3.2.3 连接之准备</span></h4><p>准备阶段是正式为类变量<strong>分配内存</strong>并<strong>设置类变量默认初始值</strong>的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量。如：<code>public static int a = 123;</code>会被赋值为0（零值），赋值为123是在之后的初始化阶段，另外，如果是<code>public static final int a = 123;</code>则会赋值为123.</p>
<h4><span id="324-连接之解析">3.2.4 连接之解析</span></h4><p>解析阶段是虚拟机将常量池内的<strong>符号引用替换为直接引用</strong>的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<blockquote>
<p><strong>再论符号引用、直接引用</strong><br><strong>符号引用（Symbolic References）</strong>：在class文件中以CONSTANT_Class_info,CONSTANT_Fieldref_info等类型的常量出现。符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可，与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。</p>
</blockquote>
<blockquote>
<p><strong>直接引用（Direct References）</strong>：直接引用可以是<br>（1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）<br>（2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）<br>（3）一个能间接定位到目标的句柄<br>直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。</p>
</blockquote>
<h4><span id="325-初始化">3.2.5 初始化</span></h4><p>类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，变量已经付过一次系统要求的初始值，而在初始化阶段，则<strong>根据程序员通过程序制定的主管计划去初始化类变量和其他资源</strong></p>
<p><strong>初始化时机：Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才初始化他们。</strong>即主动引用。</p>
<p><strong>主动引用</strong>包含以下六种情况：</p>
<ol>
<li>创建类的实例         (如在代码中new Person())</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值   (Singlean.a=8)</li>
<li>调用类的静态方法          (Singleton.getInstance();)</li>
<li>反射（如Class.forName(“com.shengsiyuan.Test”)</li>
<li>初始化一个类的子类         (有father类,有child类,且child继承或实现father类。 )</li>
<li>Java虚拟机启动时被标明为启动类的类（调用java启动命令 如Java Test）</li>
</ol>
<p>除此之外的引用方法都不会引起初始化，称为被动引用，比如：</p>
<ul>
<li>通过子类引用父类的静态字段，不会导致子类的初始化；</li>
<li>通过数组定义来引用类，不会导致此类的初始化；</li>
<li>常量在编译时期会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此调用该常量不会触发定义常量的类的初始化。</li>
</ul>
<p>类构造器<code>&lt;clinit&gt;()</code>是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}）中的语句合并产生的，顺序由语句在源文件出现的顺序决定，静态语句只能访问到在其之前定义的变量，但可以赋值。父类的类构造器会保证在子类的类构造器之前执行。类构造器在多线程环境会被加锁、同步，同时只有一个线程会去执行这个类的类构造器，且在同一类加载器中类构造器只会被调用一次。</p>
<h4><span id="326-类装载的具体例子">3.2.6 类装载的具体例子</span></h4><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span>  <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> Singleton s=<span class="keyword">new</span> Singleton();</span><br><span class="line">    public <span class="keyword">static</span> int k1;</span><br><span class="line">    public <span class="keyword">static</span> int k2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    private  Singleton() &#123;</span><br><span class="line">        k1++;</span><br><span class="line">        k2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        System.out.println(Singleton.k1);</span><br><span class="line">        System.out.println(Singleton.k2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请问：输出是什么？</p>
<p>解析：<br>在连接的准备阶段 k1,k2都是0,s是null<br>到了初始化阶段, 从上往下，s的初始化调用了构造函数，<br>k1,k2都从0变成了1，<br>继续往下，<br>k1没有被赋值还是1，<br>但是k2却被赋值为0了，<br>所以最后的结果就是：1 0</p>
<hr>
<h2><span id="4-垃圾回收机制">4. 垃圾回收机制</span></h2><h3><span id="41-垃圾回收概述">4.1 垃圾回收概述</span></h3><p>在C++中，对象所占的内存在程序结束运行之前一直被占用，在明确释放之前不能分配给其它对象。而在Java中，当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾。JVM的一个系统级线程会自动释放该内存块。垃圾回收意味着程序不再需要的对象是”无用信息”，这些信息将被丢弃。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用。事实上，除了释放没用的对象，垃圾回收也可以清除内存记录碎片。由于创建对象和垃圾回收器释放丢弃对象所占的内存空间，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存洞。碎片整理将所占用的堆内存移到堆的一端，JVM将整理出的内存分配给新的对象。</p>
<p>理解Java垃圾回收机制，需要明白下面三个问题：</p>
<ol>
<li><strong>在什么时候，什么区域？</strong> (4.3 垃圾回收区域)</li>
<li><strong>对什么东西？</strong> (4.4 垃圾回收对象)</li>
<li><strong>做了什么事情？</strong> (4.5 垃圾回收算法 4.6 垃圾回收器)</li>
</ol>
<p>在探讨Java垃圾回收机制之前，我们首先应该记住一个单词：<span style="border-bottom:2px dashed red;"><strong>Stop-the-World</strong></span>。Stop-the-world意味着 JVM由于要执行GC而停止了应用程序的执行，并且这种情形会在任何一种GC算法中发生。当Stop-the-world发生时，<strong>除了GC所需的线程以外，所有线程都处于等待状态直到GC任务完成</strong>。事实上，<strong>GC优化很多时候就是指减少Stop-the-world发生的时间</strong>，从而使系统具有 高吞吐 、低停顿 的特点。</p>
<h3><span id="42-垃圾回收意义">4.2 垃圾回收意义</span></h3><p>Java技术体系中所提倡的 <strong>自动内存管理</strong> 最终可以归结为自动化地解决了两个问题：给对象分配内存 以及 回收分配给对象的内存。</p>
<p>垃圾回收机制的引入解决了第二个问题，可以<strong>有效的防止内存泄露、保证内存的有效使用</strong>，也大大解放了Java程序员的双手，使得他们在编写程序的时候<strong>不再需要考虑内存管理</strong>。</p>
<blockquote>
<p><strong>名词解析 —— 内存泄漏</strong><br>内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为“对象游离”。</p>
</blockquote>
<h3><span id="43-垃圾回收区域">4.3 垃圾回收区域</span></h3><p>说到垃圾回收发生的区域，有必要再述Java虚拟机内存结构中的Java堆和方法区。</p>
<h4><span id="431-再述java堆">4.3.1 再述Java堆</span></h4><p>Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。这个区域是用来存放对象实例的，几乎所有对象实例都会在这里分配内存。<strong>堆是Java垃圾收集器管理的主要区域（GC堆）</strong>，垃圾收集器实现了对象的自动销毁。<strong>Java堆可以细分为：新生代和老年代；再细致一点的有Eden空间，From Survivor空间，To Survivor空间等</strong>。Java堆可以<strong>处于物理上不连续的内存空间</strong>中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。可以通过-Xmx和-Xms控制</p>
<ul>
<li><p><strong>新生代（Young Generation）</strong><br>新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的。其中Eden区存放新生对象，Survivor区存放每次垃圾回收后存活的对象</p>
</li>
<li><p><strong>老年代（Old Generation）</strong><br>老年代存放的都是一些生命周期较长的对象，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。</p>
</li>
</ul>
<h4><span id="432-再述方法区">4.3.2 再述方法区</span></h4><p>方法区也叫<strong>永久代</strong>。在过去（自定义类加载器还不是很常见的时候），类大多是”static”的，很少被卸载或收集，因此被称为“永久的(Permanent)”。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做<strong>Non-Heap（非堆）</strong>，目的应该是与Java 堆区分开来。同时，由于类class是JVM实现的一部分，并不是由应用创建的，所以又被认为是“非堆(non-heap)”内存。HotSpot 虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。<strong>对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的</strong>。</p>
<p>　　永久代也是各个线程共享的区域，它用于存储已经被虚拟机加载过的类信息，常量，静态变量（JDK7中被移到Java堆），即时编译期编译后的代码（类方法）等数据。这里要讲一下运行时常量池，它是方法区的一部分，用于存放编译期生成的各种字面量和符号引用（其实就是八大基本类型的包装类型和String类型数据（JDK7中被移到Java堆））（官方文档说明： In JDK 7, interned strings are no longer allocated in the permanent generation of the Java heap, but are instead allocated in the main part of the Java heap (known as the young and old generations), along with the other objects created by the application）。</p>
<p>　　<strong>在JDK1.7中的HotASpot中，已经把原本放在方法区的字符串常量池移出。</strong></p>
<ul>
<li>将interned String移到Java堆中</li>
<li>将符号Symbols移到native memory（不受GC管理的内存）</li>
</ul>
<p>　　从JDK7开始永久代的移除工作，贮存在永久代的一部分数据已经转移到了Java Heap或者是Native Heap。但永久代仍然存在于JDK7，并没有完全的移除：符号引用(Symbols)转移到了native heap;字面量(interned strings)转移到了java heap;类的静态变量(class statics)转移到了java heap。</p>
<p>随着JDK8的到来，JVM不再有永久代。但类的元数据信息（metadata）还在，只不过不再是存储在连续的堆空间上，而是移动到叫做“Metaspace”的本地内存（Native memory）中。</p>
<p>在JVM中共享数据空间划分如下图所示<br><img src="http://images2015.cnblogs.com/blog/908514/201607/908514-20160728195713028-1922699910.jpg" alt=""></p>
<h3><span id="44-垃圾回收种类">4.4 垃圾回收种类</span></h3><p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。垃圾回收有两种类型，Minor GC 和 Full GC。</p>
<ul>
<li><strong>Minor GC</strong>：对新生代进行回收，不会影响到年老代。因为新生代的 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般在这里使用速度快、效率高的算法，使垃圾回收能尽快完成。</li>
<li><strong>Full GC</strong>：也叫 Major GC，对整个堆进行回收，包括新生代、老年代和永久代。由于Full GC需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数，导致Full GC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。</li>
</ul>
<h3><span id="45-垃圾回收时机">4.5 垃圾回收时机</span></h3><p>那么对于 Minor GC 的触发条件：大多数情况下，直接在 Eden 区中进行分配。如果 Eden区域没有足够的空间，那么就会发起一次 Minor GC；对于 Full GC（Major GC）的触发条件：也是如果老年代没有足够空间的话，那么就会进行一次 Full GC。</p>
<p>上面所说的只是一般情况下，实际上，需要考虑一个<strong>空间分配担保</strong>的问题：</p>
<p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。如果大于则进行Minor GC，如果小于则看HandlePromotionFailure设置是否允许担保失败（不允许则直接Full GC）。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则尝试Minor GC（如果尝试失败也会触发Full GC），如果小于则进行Full GC。</p>
<p>但是，<strong>具体到什么时刻执行</strong>，这个是<strong>由系统来进行决定</strong>，终究是<strong>无法预测的</strong>。</p>
<h3><span id="46-垃圾回收对象">4.6 垃圾回收对象</span></h3><p>垃圾回收对象是<strong>可被回收的对象</strong>，判断对象可回收有两种算法：</p>
<ol>
<li><p><strong>引用计数算法</strong>：判断对象的引用数量<br>　　引用计数算法是<strong>通过判断对象的引用数量来决定对象是否可以被回收</strong>。<br>　　引用计数算法是垃圾收集器中的早期策略。在这种方法中，堆中的每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个引用变量，该对象实例的引用计数设置为 1。当任何其它变量被赋值为这个对象的引用时，对象实例的引用计数加 1（a = b，则b引用的对象实例的计数器加 1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数减 1。特别地，当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器均减 1。<strong>任何引用计数为0的对象实例可以被当作垃圾收集</strong>。<br>　　引用计数收集器可以很快的执行，并且交织在程序运行中，对程序需要不被长时间打断的实时环境比较有利，<strong>但其很难解决对象之间相互循环引用的问题</strong>。</p>
</li>
<li><p><strong>可达性分析算法</strong>：判断对象的引用链是否可达<br>　　可达性分析算法是<strong>通过判断对象的引用链是否可达来决定对象是否可以被回收</strong>。<br>　　可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，通过一系列的名为 “<strong>GC Roots</strong>” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）。当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的，如下图所示。在Java中，可作为 GC Root 的对象包括以下几种：</p>
<ul>
<li>虚拟机栈(栈帧中的局部变量表)中引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常量引用的对象；</li>
<li>本地方法栈中Native方法引用的对象；</li>
</ul>
</li>
</ol>
<p><img src="http://static.zybuluo.com/Rico123/q0t6nxkafapyn6yql7benc32/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt=""></p>
<h3><span id="47-垃圾回收算法">4.7 垃圾回收算法</span></h3><h4><span id="471-标记清除算法">4.7.1 标记清除算法</span></h4><p>标记-清除算法分为标记和清除两个阶段。该算法首先<strong>从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象并进行回收</strong></p>
<p>标记-清除算法的主要不足有两个：</p>
<ul>
<li>效率问题：标记和清除两个过程的效率都不高;</li>
<li>空间问题：标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，因此标记清除之后会<strong>产生大量不连续的内存碎片</strong>，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
<p><img src="http://static.zybuluo.com/Rico123/vmdnj50kic23uptbswo9dqnw/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.jpg" alt="标记清除算法"></p>
<p><img src="http://static.zybuluo.com/Rico123/mkqv5cf4vg8v72wvxtz0abwz/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95" alt=""></p>
<h4><span id="472-复制算法">4.7.2 复制算法</span></h4><p><strong>复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉</strong>。这种算法适用于对象存活率低的场景，比如新生代。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。该算法示意图如下所示：</p>
<p><img src="http://static.zybuluo.com/Rico123/0gzyeoiz3mf7n20jitv2g2aw/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95" alt="复制算法"></p>
<p><strong>事实上，现在商用的虚拟机都采用这种算法来回收新生代</strong>。因为研究发现，新生代中的对象每次回收都基本上只有10%左右的对象存活，所以需要复制的对象很少，效率还不错。正如在博文《JVM 内存模型概述》中介绍的那样，实践中会将新生代内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。<strong>当回收时，将Eden和Survivor中还存活着的对象一次地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间</strong>。HotSpot虚拟机默认Eden和Survivor的大小比例是 8:1，也就是每次新生代中可用内存空间为整个新生代容量的90% ( 80%+10% )，只有10% 的内存会被“浪费”。</p>
<h4><span id="473-标记整理算法">4.7.3 标记整理算法</span></h4><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。<strong>标记整理算法的标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾回收算法适用于对象存活率高的场景（老年代）</strong>，其作用原理如下图所示。</p>
<p><img src="http://static.zybuluo.com/Rico123/yn5j5ojk6mz9axjutk4hogxq/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%951.jpg" alt="标记整理算法"></p>
<p>标记整理算法与标记清除算法最显著的区别是：标记清除算法不进行对象的移动，并且仅对不存活的对象进行处理；而标记整理算法会将所有的存活对象移动到一端，并对不存活对象进行处理，因此其不会产生内存碎片。标记整理算法的作用示意图如下：</p>
<p><img src="http://static.zybuluo.com/Rico123/b26me40cjhiqkeb2vl6jb807/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="标记整理算法的作用示意图"></p>
<h4><span id="474-分代收集算法">4.7.4 分代收集算法</span></h4><p>分代收集算法是一种综合策略，对于一个大型的系统，当创建的对象和方法变量比较多时，堆内存中的对象也会比较多，如果逐一分析对象是否该回收，那么势必造成效率低下。分代收集算法是基于这样一个事实：<strong>不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域</strong>，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率。当代商用虚拟机使用的都是分代收集算法：<strong>新生代对象存活率低，就采用复制算法；老年代存活率高，就用标记清除算法或者标记整理算法</strong>。</p>
<p>1). <strong>新生代（Young Generation）</strong><br>　　新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的。新生代内存按照 8:1:1 的比例分为一个eden区和两个survivor(survivor0，survivor1)区，大部分对象在Eden区中生成。在进行垃圾回收时，先将eden区存活对象复制到survivor0区，然后清空eden区，当这个survivor0区也满了时，则将eden区和survivor0区存活对象复制到survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后交换survivor0区和survivor1区的角色（即下次垃圾回收时会扫描Eden区和survivor1区），即保持survivor0区为空，如此往复。特别地，当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代。如果老年代也满了，就会触发一次FullGC，也就是新生代、老年代都进行回收。注意，新生代发生的GC也叫做MinorGC，MinorGC发生频率比较高，不一定等 Eden区满了才触发。</p>
<p>2). <strong>老年代（Old Generation）</strong><br>　　老年代存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。此外，老年代的内存也比新生代大很多(大概比例是1:2)，当老年代满时会触发Major GC(Full GC)，老年代对象存活时间比较长，因此FullGC发生的频率比较低。</p>
<p>3). <strong>永久代（Permanent Generation）</strong><br>　　永久代主要用于存放静态文件，如Java类、方法等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如使用反射、动态代理、CGLib等bytecode框架时，在这种时候需要设置一个比较大的永久代空间来存放这些运行过程中新增的类。(注意：JDK8中，永久代已被完全移除)</p>
<h3><span id="48-垃圾回收器">4.8 垃圾回收器</span></h3><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。<strong>不同收集器之间的连线表示它们可以搭配使用</strong>。</p>
<p><img src="http://static.zybuluo.com/Rico123/9hswys8w1pqy0ch06vmlbqi2/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt=""></p>
<ul>
<li><strong>Serial收集器（复制算法)</strong>: 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li>
<li><strong>Serial Old收集器 (标记-整理算法)</strong>: 老年代单线程收集器，Serial收集器的老年代版本；</li>
<li><strong>ParNew收集器 (复制算法)</strong>: 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li>
<li><strong>Parallel Scavenge收集器 (复制算法)</strong>: 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li>
<li><strong>Parallel Old收集器 (标记-整理算法)</strong>： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li>
<li><strong>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）</strong>： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li>
<li><strong>G1(Garbage First)收集器 (标记-整理算法)</strong>： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li>
</ul>
<hr>
<h2><span id="5-class文件">5. Class文件</span></h2><h3><span id="51-无关性">5.1 无关性</span></h3><p>Java的无关性特性，准确的说应该是Java虚拟机的无关性特性，包括平台无关性与语言无关性，是建立在字节码（ByteCode）的基础之上的。平台无关性是指Java程序可以运行在任一种操作系统（平台）上，即所谓的”Write Once， Run Anywhere”。语言无关性是指Java虚拟机并不与包括Java语言在内的任何语言绑定，虽然很多程序员认为在Java虚拟机上运行Java程序是理所当然和天经地义的，但<strong>Java虚拟机实际上只和Class文件这种特殊的二进制文件关联</strong>。而且字节码比起Java语言具有更加强大的语言描述能力。<br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E8%AF%AD%E8%A8%80%E6%97%A0%E5%85%B3%E6%80%A7.JPG" alt="Java虚拟机的语言无关性"></p>
<h3><span id="52-class文件内容解析">5.2 Class文件内容解析</span></h3><p><strong>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有任何分隔符，采用大端(Big-Endian)排序方案，即高位字节在地址最低位。</strong></p>
<p>数据项目的结构与C语言的结构体类似。这种数据结构只有两种数据类型：无符号数和表，无符号数用u1、u2、u4、u8来分别表示1个字节、2个字节、4个字节、8个字节长度的无符号数，用来描述数字、索引应用、数量值或按照UTF-8编码构成字符串值。表是由多个无符号数或其他表作为数据项构成的复合数据类型，所有表习惯性地以“_info”结尾，整个Class文件实质上等同于一张表。<br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.JPG" alt="Class文件结构"></p>
<p><strong>魔数（magic）</strong>：每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是用于确定这个文件是否为一个能被虚拟机接受的Class文件，值为OxCAFEBABE。</p>
<p><strong>Class文件的版本（minor_version/major_version）</strong>：第5,6字节是次版本号（Minor Version），第7,8字节是主版本号（Major Version）,0x0033（十进制为51）表示JDK7，0x0032（十进制为50）表示JDK6。<br>比如：0xCAFEBABE00000033,表示的是能被虚拟机接受的，次版本号为0x0000，主版本号为0x0033（JDK7）的Class文件的文件头。</p>
<p><strong>常量池（constant_pool）</strong>：可理解为Class文件中的资源仓库，所占空间最大的项目之一。常量池有两类常量：字面量（Literal）和符号常量 （Symbolic References），字面量接近Java语言层面的常量概念，如：文本字符串、声明为final的常量值，符号引用属于编译原理的概念，包括三类常量：</p>
<ul>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符<br>共有14种项目类型：<br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E5%B8%B8%E9%87%8F%E6%B1%A0%E9%A1%B9%E7%9B%AE%E7%B1%BB%E5%9E%8B.JPG" alt="常量池项目类型"></li>
</ul>
<blockquote>
<p><strong>名词解释————全限定名、简单名称、描述符</strong><br>全限定名（Fully Qualified Name）：某个类的全名为pers.kanarien.study.TestClass，则全限定名为pers/kanarien/study/TestClass，多个全限定名使用”;”间隔<br>简单名称：指没有类型或参数修饰的方法或字段名称，如方法test()和字段int a的简单名称分别为test和a<br>描述符（Descriptor）：用来描述字段的数据类型、方法的参数列表（包括数量、类型、顺序）和返回值<br>  <img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E5%AD%97%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6.JPG" alt="字段描述符"></p>
</blockquote>
<p><strong>访问标志（access_flags）</strong>：表示一个类或接口层次的访问信息，包括这个Class文件是类还是接口；是否定义为public类型；是否定义为abstract类型等<br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.JPG" alt="访问标志"></p>
<p><strong>类索引（this_class）、父类索引（super_class）、接口索引集合（interfaces）</strong>：Class文件由以上三项确定继承关系。类索引用于确定这个类的全限定名；父类索引用于确定父类的全限定名；接口索引集合描述这个类实现了哪些接口。</p>
<p><strong>字段表集合（field_info）</strong>：用于描述接口或类中声明的变量。字段包括类变量和实例级变量，不包括方法内的局部变量。字段包含的信息有：字段的作用域（public、private、protected修饰符）、实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。字段表结构如下：<br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%BB%93%E6%9E%84.JPG" alt="字段表结构"></p>
<p>字段表集合不会列出从超类或父接口中继承而来的字段，但可能列出Java代码中不存在的字段，比如内部类为了保持对外部类党的访问性，自动添加指向外部类实例的字段。另外，Java语言中字段是无法重载的，即两个字段的名称必须不一样，但对字节码来说，两个字段的描述符不一致，字段重名是合法的。</p>
<p><strong>方法表集合（method_info）</strong>：与字段表集合类似，而方法中的Java代码存放在方法属性表一个名为“Code”的属性里面<br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E6%96%B9%E6%B3%95%E8%A1%A8%E9%9B%86%E5%90%88.JPG" alt="方法表结构"></p>
<p><strong>属性表集合(attribute_info)</strong>：Class文件、字段表、方法表都可以拥有自己的属性表集合，属性表不要求有严格的顺序。对于每个属性，它的名称都是从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构是完全自定义的，只需一个u4的长度属性去说明属性值所占的位数即可。<br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E5%B1%9E%E6%80%A7%E8%A1%A8%E7%BB%93%E6%9E%84.JPG" alt="属性表结构"></p>
<p><strong>Java虚拟机规范中定义的属性</strong>：<br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B1%9E%E6%80%A7%281%29.JPG" alt="Java虚拟机规范中定义的属性"><br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B1%9E%E6%80%A7%282%29.JPG" alt="Java虚拟机规范中定义的属性"><br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B1%9E%E6%80%A7%283%29.JPG" alt="Java虚拟机规范中定义的属性"><br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B1%9E%E6%80%A7%284%29.JPG" alt="Java虚拟机规范中定义的属性"></p>
<ul>
<li><strong>Code属性：Java程序方法体中的代码经过Javac编译器处理后，最终变成字节码指令存储在Code属性内。</strong> Code属性出现在方法表的属性表集合之中，但并非所有方法都有Code属性，比如接口和抽象类中的方法。一个实例方法，至少有一个参数和一个本地变量，原因是<code>this</code>关键字。任何实例方法内，都可以通过<code>this</code>关键字访问到此方法所属的对象，而Javac编译器编译的是否隐式的对this关键字的访问转变为对一个普通方法参数的访问，然后虚拟机在调用实例方法时自动传入此参数而已。Code属性有一个显式异常处理表(exception_info)如表6-16,用来实现Java异常和finally处理机制。<br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/Code%E5%B1%9E%E6%80%A7%E8%A1%A8%E7%BB%93%E6%9E%84.JPG" alt="Code属性表结构"><br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E5%BC%82%E5%B8%B8%E8%A1%A8%E7%BB%93%E6%9E%84.JPG" alt="异常表结构"></li>
<li>Exceptions属性：列举方法中可能抛出的受查异常，也就是方法描述时在<code>throws</code>关键字后面列举的异常。</li>
<li>LineNumberTable属性：用于描述Java源码行号与字节码行号（字节码偏移量）之间的对应关系。默认会生成到Class文件之中。如果不生成该属性，程序抛出异常时，堆栈不会显示行号，也无法设置断点调试程序。</li>
</ul>
<h3><span id="53-字节码指令">5.3 字节码指令</span></h3><p>Java虚拟机的指令由一个字节长度的操作码，及其后若干的操作数组成。由于Java虚拟机采用面向操作数栈而不是寄存器的架构，因此大多数指令只有一个操作码，没有操作数。不考虑异常处理，Java虚拟机的最基本的执行模式如下伪代码所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    自动计算PC寄存器的值加1；</span><br><span class="line">    根据PC寄存器指出的位置，从字节码流中取出操作码；</span><br><span class="line">    if (字节码存在操作数) 从字节码流中读出操作数；</span><br><span class="line">    执行操作码定义的操作；</span><br><span class="line">&#125; while (字节码流长度 &gt; 0)</span><br></pre></td></tr></table></figure></p>
<p>Java虚拟机指令集中，大多数的指令的本身包含了其操作所对应的数据类型信息，如iload指令用于从局部变量表中加载int型数据到操作数栈，而fload用于float类型的数据。由于操作码长度只有1个字节(256种情况)，所以<strong>并非每一种数据类型和每一种操作都有对应的指令（Not Orthogonal）</strong> 。大部分指令都没有支持byte、char、short、boolean，编译器会在编译期或运行期将byte、char、short、boolean扩展为int型数据，其数组转换为int型数组，即byte、char、short、boolean类型的数据操作，实际上是使用相应的int型作为运算类型。</p>
<h3><span id="54-java虚拟机的实现方式">5.4 Java虚拟机的实现方式</span></h3><p>Java虚拟机的实现方式有两种：</p>
<ol>
<li>将输入的Java虚拟机的代码在加载或执行时翻译成另一种虚拟机的指令集。</li>
<li>将输入的Java虚拟机的代码在加载或执行时翻译成宿主机CPU的本地指令集</li>
</ol>
<hr>
<h2><span id="6-字节码执行引擎">6. 字节码执行引擎</span></h2><p>执行引擎在执行Java代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备。</p>
<h3><span id="61-栈帧">6.1 栈帧</span></h3><p>栈帧（Stack Frame）是虚拟机运行时数据区中虚拟机栈中的处理元素，存储了局部变量表、操作数栈、动态链接和方法返回地址等信息。<strong>每一个方法的调用开始到完成的过程，对应着一个栈帧在虚拟机栈从入栈到出栈的过程</strong>。</p>
<h4><span id="611-局部变量表">6.1.1 局部变量表</span></h4><p>局部变量表（Local Variable Table）是<strong>一组变量值存储空间，存放方法的参数和方法内的局部变量</strong>。局部变量表的容量以变量槽（Variable Slot，简称Slot）为单位，大小一般为32位或64位，要求是一个Slot可以存放一个32位以内的数据类型。虚拟机通过索引定位的方式使用局部变量表，索引值范围从0到最大的Slot数量。对实例方法而言，第0位索引是对对象实例本身的引用，即<code>this</code>，其后按顺序依次为方法的参数和方法体内的局部变量。</p>
<blockquote>
<p>不使用的对象应手动置为null   ————《Practical Java》</p>
</blockquote>
<p>这句话看起来很奇怪，实际上这与Slot的重用（内存的重用）有关。在同一个方法体内，后面的代码有一些耗时很长的操作，而前面的代码又定义了大量内存、实际上已经不会再使用的变量，手动置为null值，把变量对应的Slot清空，让Slot占用的空间能够被其他变量复用。需要注意的是，这种手动置null的用法仅在某种特殊的情况下使用，理由有两点：</p>
<ol>
<li>恰当的变量作用域来控制变量回收时间才是最优雅的解决办法；</li>
<li>代码经过JIT编译器后，会对代码产生很大程度上的优化，置null值的操作会被JIT编译优化后消除掉。</li>
</ol>
<p>另外，局部变量不同于类变量，如果一个局部变量定义了但没有赋初值是不能使用的（没有系统默认值），好在编译时就会有提醒。</p>
<h3><span id="62-方法调用">6.2 方法调用</span></h3><p>方法调用不等于方法执行，方法调用唯一的目的是确定被调用的方法的版本（调用哪一个方法），而不涉及方法内部的执行。一切方法在Class文件中只是符号引用，需要找出对应的直接引用才能执行。</p>
<h4><span id="621-再论类加载的解析">6.2.1 再论类加载的解析</span></h4><p>类加载的解析阶段是虚拟机将常量池内的<strong>符号引用替换为直接引用</strong>的过程。而该时期解析的方法是非虚方法，即</p>
<ul>
<li>静态方法</li>
<li>私有方法</li>
<li>实例构造器</li>
<li>父类方法</li>
<li>final修饰的方法<br>除此之外的方法属于虚方法。解析调用在编译时期就完全确定，在类加载时期的解析阶段就好将符号引用替换为直接引用，不需要等到运行期。</li>
</ul>
<h4><span id="622-静态分派静态绑定">6.2.2 静态分派（静态绑定）</span></h4><p>虚方法的<strong>静态分派（静态绑定）与Java面向对象特性中的重载密切相关</strong>，发生在编译期。看下面的一段代码，试想输出是什么。<br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package com.jvm;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态分派</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Women</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">void</span> sayHello(Human guy) &#123;</span><br><span class="line">        System.out.println(<span class="string">"hello, guy!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> sayHello(Man guy) &#123;</span><br><span class="line">        System.out.println(<span class="string">"hello, man!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> sayHello(Women guy) &#123;</span><br><span class="line">        System.out.println(<span class="string">"hello, women!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args)&#123;</span><br><span class="line"></span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human women = <span class="keyword">new</span> Women();</span><br><span class="line"></span><br><span class="line">        StaticDispatch sd = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sd.sayHello(man);</span><br><span class="line">        sd.sayHello(women);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello, guy!</span><br><span class="line">hello, guy!</span><br></pre></td></tr></table></figure></p>
<p>上面代码中的“Human”称为变量的静态类型（Static Type），后面的Man称为变量的实际类型（Actual Type）。静态类型的最终类型在编译期是可知的，但实际类型只在运行期才确定。，虚拟机（准确来说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判断依据的。另外，对于字面量，如<code>sayHello(&#39;a&#39;)</code>中的a参数，由于其本身不需要定义，故没有显示的静态类型，因此编译器只能选择更接近、更合适的类型的方法来调用。</p>
<p>对应的字节码指令是<code>invokestatic</code>或<code>invokespecial</code>加符号引用</p>
<h4><span id="623-动态分派动态绑定">6.2.3 动态分派（动态绑定）</span></h4><p>虚方法的<strong>动态分派（动态绑定）与Java面向对象特性中的重写密切相关</strong>，发生在运行期。看下面的一段代码，试想输出是什么。<br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.jvm;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态分派</span></span><br><span class="line"><span class="comment"> * @author renhj</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> abstract <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">	    protected abstract <span class="keyword">void</span> sayHello();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	    @Override</span><br><span class="line">	    protected <span class="keyword">void</span> sayHello() &#123;</span><br><span class="line">	        System.out.println(<span class="string">"hello man!"</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Women</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	    @Override</span><br><span class="line">	    protected <span class="keyword">void</span> sayHello() &#123;</span><br><span class="line">	        System.out.println(<span class="string">"hello women!"</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args)&#123;</span><br><span class="line"></span><br><span class="line">    	Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human women = <span class="keyword">new</span> Women();</span><br><span class="line"></span><br><span class="line">        man.sayHello();</span><br><span class="line">        women.sayHello();</span><br><span class="line"></span><br><span class="line">        man = <span class="keyword">new</span> Women();</span><br><span class="line">        man.sayHello();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man say hello</span><br><span class="line">woman say hello</span><br><span class="line">woman say hello</span><br></pre></td></tr></table></figure></p>
<p>相同的静态类型调用同一方法却输出不同结果，原因是重写使用动态分配的方式，根据实际类型去调用相关的方法，字节码对应的指令为<code>invokevirtual</code>加上符号引用</p>
<h4><span id="624-动态类型语言">6.2.4 动态类型语言</span></h4><p>动态类型语言的特征是类型检查的主体过程是在运行期而不是编译期，比如JavaScript、PHP、Ruby、Groovy等。动态类型语言编译时最多只确定方法名称、参数、返回值等信息，而不会去确定方法所在的具体类型（方法接受者不固定）。可理解为：“变量无类型而变量值才有类型”。</p>
<p>静态类型语言在编译器确定好类型，编译器可提供严谨的类型检查，利于稳定性与大规模的代码；动态类型语言运行期确定类型，为开发人员提供更大的灵活性，代码更加的简洁、清晰。</p>
<p>Java属于动态类型语言，JDK7中提供的java.lang.invoke包中提供的API实现了一定程度上动态语言的特性，JDK7以前单纯依靠符号引用来确定调用的目标方法，而invoke包提供了一种新的动态确定目标方法的机制，称为“MethodHandle”（可获得一个虚方法的句柄），为JDK8的Lambda表达式提供了实现基础。</p>
<h3><span id="63-解释执行">6.3 解释执行</span></h3><p>Java被定位为“解释执行”的语言，但随着技术的发展，主流的虚拟机都包括了JIT编译器，Class文件的代码到底是解释执行还是编译执行只能虚拟机自己才知道了。</p>
<p>典型的解释执行概念模型中，一个实例方法中的简单的四则远算的具体执行步骤如下：</p>
<ol>
<li>操作数入操作数栈；</li>
<li>操作数栈中的操作数存入局部变量Slot；</li>
<li>所有操作数都存入完毕后，从局部变量表加载所需要的数据到操作数栈；</li>
<li>以栈顶两个操作数为一次运算的运算元素进行运算，结果放栈顶，重复运算知道算出最终结果；</li>
<li>返回栈顶元素。</li>
</ol>
<h4><span id="631-编译过程">6.3.1 编译过程</span></h4><p>现大多高级语言都遵循经典编译原理，在执行前对源码进行词法分析和语法分析，把源码转换为抽象语法树，如下图所示。其中最下方的路径为生成目标机器代码的过程，代表语言C/C++；中间的路径就是解释执行，代表语言Java；又或者把这些步骤和执行引擎一起封装，如JavaScript执行器。<br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.JPG" alt="编译过程"></p>
<h4><span id="632-基于栈的指令集与基于寄存器的指令集">6.3.2 基于栈的指令集与基于寄存器的指令集</span></h4><p>Java虚拟机使用基于栈的指令集，而主流的PC大都使用基于寄存器的指令集。</p>
<p>使用基于寄存器的指令集有以下优点：</p>
<ul>
<li>可移植性高，不必依赖硬件寄存器；</li>
<li>编译器实现简单；</li>
<li>代码更加紧凑（字节码大都是单字节）</li>
</ul>
<p>使用基于寄存器的指令集一个显著的缺点是执行效率慢，原因有：</p>
<ul>
<li>完成相同功能需要更多的指令；</li>
<li>频繁访存。</li>
</ul>
<hr>
<h2><span id="7-编译期优化">7. 编译期优化</span></h2><p>Java语言的编译期是一段不确定的操作过程，因为它可能是指一个前端编译器（或叫编译器的前端）把 <em>.java文件 转变成 </em>.class文件 的过程；也可能是虚拟机的后端运行期编译器（JIT编译器，Just in Time Compiler）把字节码抓变成机器码的过程；还可能是指使用静态提前编译器（AOT编译器，Ahead Of Time Compiler）  直接把 *.java 文件编译成本地机器代码的过程。具体有：</p>
<ul>
<li>前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）；</li>
<li>JIT编译器：HotSpot VM的C1、C2编译器；</li>
<li>AOT编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</li>
</ul>
<h3><span id="71-sun-javac-编译过程">7.1 Sun Javac 编译过程</span></h3><p>虚拟机严格定义了Class文件的格式，但并没有对如何把Java源码转变为Class文件的编译过程进行严格的定义。某些情况下，会出现Javac编译器可以编译而ECJ编译器不可编译的问题。</p>
<p>对Sun Javac而言，编译过程如图所示：<br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/Sun%20Javac%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.JPG" alt="Sun Javac编译过程"></p>
<p>主体代码如下：<br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/Sun%20Javac%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%B8%BB%E4%BD%93%E4%BB%A3%E7%A0%81.JPG" alt="Sun Javac编译主体代码"></p>
<h4><span id="711-解析和填充符号表">7.1.1 解析和填充符号表</span></h4><p><strong>词法分析</strong><br>词法分析是将源代码的字符流转变为标记（Token）集合，标记是编译过程的最小元素，如：关键字、变量名、字面量、运算符。</p>
<p><strong>语法分析</strong><br>语法分析是根据Token序列构造抽象语法树（Abstract Syntax Tree，AST）的过程，AST用来描述程序代码语法结构的树形表示方式，每一节点代表程序代码中的一个语法结构</p>
<p><strong>填充符号表</strong><br>符号表（Symbol Table）是由一组符号地址和符号信息构成的表格，类似哈希表的K-V形式。在语义分析阶段，符号表用来语义检查和产生中间代码；在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。</p>
<h4><span id="712-注解处理器">7.1.2 注解处理器</span></h4><p>在JDK5之后，Java提供了注解（Annotation）的支持，这些注解和普通的Java代码一样，在运行期发挥作用，。在JDK6中，提供的插入时注解处理器在编译期对注解进行处理，可以把插入式注解处理器看成一组编译器的插件，能够插入、修改、读取抽象语法树的任一元素。每次处理称为一个Round，也就是Sun Javac编译过程中的回环。</p>
<h4><span id="713-语义分析">7.1.3 语义分析</span></h4><p>语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的检查，包括标注检查和数据及控制流检查。</p>
<p><strong>标注检查</strong>：标注检查的步骤包括如变量使用前是否声明、变量与赋值类型是否匹配等，以及需要特别说明的<strong>常量折叠</strong>。如果在代码中写了<code>int _2kb = 1024 * 2;</code>，经常量折叠后，表达式的值会在语法树上标注出来（ConstantValue：2048），由于在编译期进行了常量折叠，并不会在运行期增加CPU的运算量。</p>
<p><strong>数据及控制流分析</strong>：数据及控制流分析是对程序上下文逻辑更进一步的验证，可以检查出如程序局部变量在使用前是否赋值、方法的每条路径是否都有返回值、是否所有受查异常都被正确处理等。编译期的数据及控制流分析与类加载时的数据及控制流分析基本一致，但校检范围有所区别，有一些校检项只在编译期或运行期进行。</p>
<p><strong>解语法糖</strong>：语法糖（Syntactic Sugar），也称糖衣语法。指计算机语言中添加的某种语法，这种语法对语言功能并没有影响，但更方便程序员的使用，增加程序可读性，在Java中有如：泛型、变长参数、自动装箱/拆箱等。在编译阶段将语法糖还原回简单的基础语法结构，称为解语法糖。</p>
<h4><span id="714-字节码生成">7.1.4 字节码生成</span></h4><p>Javac编译的最后一个阶段，将生成的语法树、符号表转化成Class文件，以及少量的代码添加、转换工作，如实例构造器<code>&lt;init()&gt;</code>和类构造器<code>&lt;clinit()&gt;</code>就是在这阶段添加到语法树中。</p>
<h3><span id="72-java语法糖糖衣背后的真实">7.2 Java语法糖——糖衣背后的真实</span></h3><p>语法糖虽然不会提供实质性的功能改进，但它们或能提高效率，或能提升语法的严谨性，或能减少编码出错的机会。但我们也要认清糖衣背后的真实，看清程序的真面目。</p>
<h4><span id="721-泛型与类型擦除">7.2.1 泛型与类型擦除</span></h4><p>泛型是JDK5的一项新特性，<strong>本质是参数化类型（Parametersized Type）的应用</strong>。在Java语言<strong>还没有泛型的时候，通过Object是所有类型的父类以及强制类型转换配合使用实现泛型化</strong>。在C#和Java中的泛型有着根本性的区别，C#的泛型无论在源码中、编译后、运行时都是真实存在的，<code>List&lt;Integer&gt;</code>和<code>List&lt;String&gt;</code>是两个不同的类型，在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，；Java的泛型只存在于源码中，编译后的Class文件中已经变为原生类型了，并且在相应地方加入了强制类型转换，对于运行期的Java语言来说，<code>List&lt;Integer&gt;</code>和<code>List&lt;String&gt;</code>是同一个类，这种实现方法称为类型擦除，属于伪泛型。</p>
<p>下面举一个例子说明，类型擦除前的代码：<br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E7%9A%84%E4%BE%8B%E5%AD%90.JPG" alt="类型擦除的例子"></p>
<p>由编译出的Class文件，再反编译回去的代码：<br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E7%9A%84%E4%BE%8B%E5%AD%902.JPG" alt="类型擦除的例子"></p>
<p>当泛型遇上重载，如下代码：<br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> method(List&lt;<span class="built_in">String</span>&gt; list) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">void</span> method(List&lt;Integer&gt; list) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是不能通过编译的，因为类型擦除后，方法的参数都是List（对于JDK6而言，如果返回类型不一样是能够编译的，原因在于描述符不同的方法在Class文件中能够共存，之后的版本不可编译）。</p>
<p>另外类型擦除通过Java虚拟机规范后来加入的两个属性：Signature和LocalVariableTypeTable，可以通过反射获得实际的类型参数而不是原生类型。</p>
<h4><span id="722-遍历循环与变长参数">7.2.2 遍历循环与变长参数</span></h4><p>遍历循环（Foreach）使用关键字<code>for( : )</code>实现，变长参数指方法的参数长度不定，如下代码：<br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="keyword">new</span> Integer(<span class="number">1</span>), <span class="keyword">new</span> Integer(<span class="number">2</span>), <span class="keyword">new</span> Integer(<span class="number">3</span>));</span><br><span class="line"><span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">  System.out.println(i.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由编译出的Class文件，再反编译回去的代码：<br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List list = Arrays.asList(<span class="keyword">new</span> Integer[] &#123;</span><br><span class="line">  <span class="keyword">new</span> Integer(<span class="number">1</span>),</span><br><span class="line">  <span class="keyword">new</span> Integer(<span class="number">2</span>),</span><br><span class="line">  <span class="keyword">new</span> Integer(<span class="number">3</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Iterator localIterator = list.iterator(); localIterator.hasNext(); ) &#123;</span><br><span class="line">  Integer i = ((Integer)localIterator.next());</span><br><span class="line">  System.out.println(i.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>显然，遍历循环是依赖Iterable接口实现的，而变长参数语法是通过数组完成的。</p>
<h4><span id="723-自动装箱-自动拆箱与-equals">7.2.3 * 自动装箱、自动拆箱与“==”、“equals()”</span></h4><p><strong>自动装箱</strong>指的是用基本类型的值给它的包装类赋值时，系统会自动将基本类型转换成它的包装类型。实际上，系统自动调用Integer.valueOf()方法来完成转换。JDK源码如下:<br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> Integer valueOf(int i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>先判断能不能冲缓存中获取，否则new一个Integer对象</strong>。</p>
<p>关于<code>IntegerCache</code>的源码如下：<br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> final int low = <span class="number">-128</span>;</span><br><span class="line"><span class="keyword">static</span> final int high;</span><br><span class="line"><span class="keyword">static</span> final Integer cache[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// high value may be configured by property</span></span><br><span class="line">    int h = <span class="number">127</span>;</span><br><span class="line">    <span class="built_in">String</span> integerCacheHighPropValue =</span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">    <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            int i = <span class="built_in">parseInt</span>(integerCacheHighPropValue);</span><br><span class="line">            i = <span class="built_in">Math</span>.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = <span class="built_in">Math</span>.min(i, Integer.MAX_VALUE - (-low) <span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">            <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">    int j = low;</span><br><span class="line">    <span class="keyword">for</span>(int k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">    assert IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>意思是，默认情况下创建一个Integer数组的缓存，默认情况下该缓存的内容是值为-128到127的Integer对象。</p>
<p><strong>自动拆箱</strong>和自动装箱相反，当需要基本类型的时候，系统也会自动的将包装类转换成基本类型。实际上，系统自动调用Integer.intValueOf方法来完成转换。JDK源码如下:<br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int intValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再来看下“==”和“equals()”</p>
<ul>
<li><code>==</code>运算符，如果是<strong>基本数据类型，则直接对值进行比较</strong>，如果是<strong>引用数据类型，则是对他们的地址进行比较</strong>（但是<strong>只能比较相同类型的对象</strong>，或者比较父类对象和子类对象。类型不同的两个对象不能使用==）</li>
<li><code>equals()</code>方法，继承自Object类，在具体实现时可以覆盖父类中的实现。看一下Object中qeuals的源码发现，它的实现<strong>也是对对象的地址进行比较</strong>，此时它和”==”的作用相同。而JDK类中有一些类<strong>覆盖</strong>了Object类的equals()方法，比较规则为：<strong>如果两个对象的类型一致，并且内容一致</strong>，则返回true,这些类有：<br>java.io.file,java.util.Date,java.lang.string，包装类（Integer,Double等）。</li>
</ul>
<p>看如下代码，思考输出：<br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span> args[]) &#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3</span>L;</span><br><span class="line">        int x = <span class="number">3</span>;</span><br><span class="line">        long y = <span class="number">3</span>L;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//x,y虽然类型不同但是可以直接进行数值比较</span></span><br><span class="line">        System.out.println(x == y);         <span class="comment">//true，int类型向long类型对齐，从二进制角度表示来看，显然值相等</span></span><br><span class="line">        <span class="comment">//System.out.println(c == g); 提示出错，不可比较的类型。说明此时没有自动拆箱</span></span><br><span class="line">        System.out.println(c == d);         <span class="comment">//true，两个在IntegerCache范围的的Integer类型进行比较，同一个引用地址进行比较</span></span><br><span class="line">        System.out.println(e == f);         <span class="comment">//false，两个不在IntegerCache范围的的Integer类型进行比较，不同引用地址进行比较</span></span><br><span class="line">        System.out.println(c == (a+b));     <span class="comment">//true，有“+”运算符，“a+b”自动拆箱后进行运算，变量“c”也自动拆箱，对值进行比较</span></span><br><span class="line">        System.out.println(c.equals(a+b));  <span class="comment">//true，有“+”运算符，“a+b”自动拆箱后进行运算，对值进行自动装箱，对对象类型以及值进行比较</span></span><br><span class="line">        <span class="comment">//此时进行了自动的拆箱</span></span><br><span class="line">        System.out.println(g == (a+b));     <span class="comment">//true，有“+”运算符，“a+b”自动拆箱后进行运算，对值进行比较</span></span><br><span class="line">        System.out.println(g.equals(a+b));  <span class="comment">//false，有“+”运算符，“a+b”自动拆箱后进行运算，对值进行自动装箱，对对象类型以及值进行比较</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4><span id="724-条件编译">7.2.4 条件编译</span></h4><p>Java语言也有条件编译，方法是也只是条件为常量的if语句，具体例子如下代码：<br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">"block1"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"block2"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由编译出的Class文件，再反编译回去的代码如下：<br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">  System.out.println(<span class="string">"block1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于使用了if语句，所以只能写在方法体内，实现语句块（Block）级别的条件编译，而没办法实现根据条件调整整个Java类的结构。</p>
<hr>
<h2><span id="8-运行期优化">8. 运行期优化</span></h2><h3><span id="81-jit编译器">8.1 JIT编译器</span></h3><p>当虚拟机发现<strong>某个方法或代码块的运行特别频繁</strong>的时候，就会把这些代码认定为<strong>热点代码</strong>（Hot Spot Code）。为了提高热点代码的执行效率，运行时虚拟机会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器叫做即时编译器（Just In Time Compiler，JIT编译器）。</p>
<p>Java虚拟机规范并没有规定Java虚拟机时候一定要有JIT编译器，更没有规定具体实现的细节，但JIT编译器性能的好坏，代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键指标之一，也是虚拟机中最核心、最能体现虚拟机技术水平的部分。</p>
<h3><span id="82-解释器与编译器">8.2 解释器与编译器</span></h3><p>主流的虚拟机很多都采用<strong>解释器与编译器并存</strong>的架构。当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译时间，立即执行；程序运行后，随着时间推移，编译器逐渐发挥作用，把越来越多代码编译成本地代码，可以获取更高的执行效率。当程序运行环境中内存限制较大，可以使用解释执行节省内存，反之使用编译执行提升效率。另外，当激进优化的假设不成立时，可通过逆优化退回到解释状态继续执行。</p>
<blockquote>
<p>三大商用虚拟机中的JRockit内部没有解释器，它主要面向服务端的应用，这类应用一般不重点关注启动时间。</p>
</blockquote>
<p>HotSpot虚拟机中内置了两个JIT编译器，分别称为Client Compiler和Server Compiler，或简称为C1编译器和C2编译器（也叫Opto编译器）。为了在程序启动响应速度和运行效率之间取得平衡，HotSpot虚拟机采用<strong>分层编译</strong>（Tiered Compilation）策略。分层编译根据编译器编译、优化的规模和耗时，划分出不同编译层次，包括：</p>
<ul>
<li>第0层，程序解释执行，解释器不开启性能监控功能，可触发第1层编译。</li>
<li>第1层，也称为C1编译，将字节码编译成本地代码，进行简单的、可靠的优化，如有必要加入性能监控逻辑。</li>
<li>第2层（或以上），也称为C2编译，也是将字节码编译成本地代码，但会开启一些编译耗时较长的优化，甚至根据性能监控信息开启一些不可靠的激进优化。</li>
</ul>
<h3><span id="83-编译对象与触发条件">8.3 编译对象与触发条件</span></h3><p>被JIT编译器编译的代码有两类：</p>
<ul>
<li>被多次调用的方法</li>
<li>被多次执行的循环体</li>
</ul>
<p>对于第一种情况，由于是方法调用触发的编译，编译器会把整个方法当成编译的对象（JIT标准编译方式）；对于第二种情况，编译器仍会以整个方法作为编译对象，但由于发生在循环体执行的过程中，因此形象地称为栈上替换（On Stack Reaplacement，OSR）。</p>
<p>判断代码是不是热点代码，是否需要出发即时编译，称为热点探测（Hot Spot Detection），主要有两种方式：</p>
<ul>
<li><strong>基于采样的热点探测</strong>（Sample Based Hot Spot Detection）：虚拟机会周期性检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那个方法就是热点方法。优点：实现简单、高效，容易获取方法调用关系，缺点：难以精确确认一个方法的热度，易受线程阻塞和外界因素干扰。</li>
<li><strong>基于计数器的热点探测</strong>（Counter Based Hot Spot Detection）：为每个方法（甚至代码块）建立计数器，统计方法的执行次数，执行次数超过一定的阈值就是热点方法。优点:统计结果精确严谨，缺点：实现麻烦，为每个方法维护一个计数器，不能直接获取方法调用关系。</li>
</ul>
<p>Hot Spot虚拟机使用基于计数器的热点探测，为每个方法准备了两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）</p>
<p>显然，方法调用计数器统计的是方法调用的次数，方法调用计数器触发即时编译的流程图如下：<br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A7%A6%E5%8F%91%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91.JPG" alt="方法调用计数器触发即时编译"></p>
<p>缺省情况下，当超过一定的时间限度，方法调用次数不足以触发即时编译，则方法计数会减少一半，称为<strong>计数器的热度衰减</strong>（Counter Decay），这段时间称为半衰周期（Counter Half Life Time）</p>
<p>回边计数器统计一个方法中循环体代码执行的次数，回边指的是在字节码中遇到控制流向后跳转的指令，其触发流程与方法调用计数器类似。但回边计数器没有热度衰减。</p>
<h3><span id="84-编译过程">8.4 编译过程</span></h3><p>编译未完成时，仍以解释执行的方式去执行。Client Compiler的编译过程分为三个阶段：<br><img src="http://kanarien-1254133416.cosgz.myqcloud.com/Image%20Bed/Client%20Compiler%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.JPG" alt="Client Compiler的编译过程"></p>
<p>Server Compiler专门面向服务端的应用而特别调整，较为复杂，会执行所有经典的优化动作，虽然编译速度比Client Compiler慢，但比静态优化编译器要快得多。</p>
<h3><span id="85-编译技术">8.5 编译技术</span></h3><h4><span id="851-公共子表达式消除">8.5.1 公共子表达式消除</span></h4><p>如果一个表达式E已经计算过，并且从先前的计算到现在的E中所有变量的值都没有发生变化，那么E的这次出现就成为了公共子表达式。对于这种表达式，直接使用前面计算的结果代替即可。举个例子，有以下的计算式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int s = (c * b) * 12 + a + (a + b * c);</span><br></pre></td></tr></table></figure></p>
<p>可优化为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int s = E * 12 + a + (a + E);</span><br></pre></td></tr></table></figure></p>
<h4><span id="852-数组边界检查消除">8.5.2 数组边界检查消除</span></h4><p>Java是一门动态安全的语言，对数组的读写访问不像C/C++那样本质是裸针操作。在访问数组的时候，系统会自动进行上下界检查，即<strong>隐式的条件判断</strong>，对有大量的数组访问操作的代码来说，这会一定程度上影响到性能，但又不能不检查。但实际上，不是每次访问数组都必须要检查一遍的，比如：数组下标是个常量，编译期根据数据流分析判断是否越界，运行期就不用判断了。又如数组访问发生在循环中，使用循环变量进行访问，同样通过数据流分析判断循环变量是否在数组大小范围内，就可以消除检查。</p>
<h4><span id="853-方法内联">8.5.3 方法内联</span></h4><p>方法内联是编译器最重要的优化手段之一，除了消除方法调用的成本外，还为其他优化手段建立基础。方法内联的优化行为看似很简单，不过是把目标方法的代码“复制”到发起调用的方法之中，避免发生真实的方法调用。但实际上，<strong>除了之前说过的非虚方法，其他方法在调用时都要进行方法接收者的多态选择</strong>，并且可能存在多个方法版本，特别是动态分派的重写方法，只能在运行期判断方法接收者是子类还是父类。</p>
<p>为了解决虚方法的方法内联问题，Java虚拟机团队引入了一种名为“<strong>类型继承分析</strong>”（Class Hierarchy Analysis，CHA）的技术，用于确定在目前已加载的类中，某接口是否有多于一种的实现，某个类是否存在子类等信息。</p>
<p>编译器在进行内联时，非虚方法直接内联，虚方法则向CHA查询是否有多个方法版本，如果查询结果只有一个，则可以进行内联，不过这种内联属于激进优化，需要预留一个“逃生门”，称为<strong>守护内联</strong>（Guarded Inlining），如果后续的程序加载了导致继承关系发生变化的新类，那就需要抛弃已经编译的代码，退回解释执行或重新编译。如果CHA查询结果有多个结果可以选择，编译器会使用内联缓存来完成方法内联，工作原理为：未发生方法调用前，内联缓存为空，当第一次方法调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较方法接收者的版本，如果方法接受者的版本一样，那这个内联可以一直用下去，否则取消内联，查找虚方法表进行方法分派。</p>
<h4><span id="854-逃逸分析">8.5.4 逃逸分析</span></h4><p>逃逸分析（Escape Analysis）的基本行为是分析对象动态作用域：当<strong>一个对象在方法中被定义后</strong>，它<strong>可能被外部方法所引用</strong>，例如作为参数传递到其他方法，称为方法逃逸；甚至可能被外部线程访问，譬如赋值给类变量或可以在其他线程中访问到的实例变量，称为线程逃逸。</p>
<p>如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问这个对象，则可对这个对象做些优化：</p>
<ul>
<li><strong>栈上分配</strong>（Stack Allocation）：让对象在栈上分配而不是在堆上，对象所占的内存虽栈帧出栈而释放。</li>
<li><strong>同步消除</strong>（Synchronization Elimination）：一个变量不会逃逸出线程，那这个变量的读写就不会有竞争，对这个变量实施的同步措施就可以消除掉。</li>
<li><strong>标量替换</strong>（Scalar Replacement）：标量（Scalar）是指一个数据已经无法再分解成更小的数据来表示了，如：Java虚拟机中的原始类型（int、long等基本数据类型以及引用类型）。相对的，如果一个数据可以继续分解，那么它就被称作聚合量（Aggregate），如Java中的对象。将一个Java对象拆散，根据程序访问的情况，将使用到的成员变量恢复原始类型来访问就叫标量替换。</li>
</ul>
<hr>
<blockquote>
<p>Copyright © 2018, GDUT CSCW back-end Kanarien, All Rights Reserved</p>
</blockquote>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2018/07/22/Java虚拟机——学习笔记/">Java虚拟机——学习笔记</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">Kanarien</a></p>
        <p><span>发布时间:</span>2018-07-22, 20:49:43</p>
        <p><span>最后更新:</span>2018-07-22, 20:54:24</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/07/22/Java虚拟机——学习笔记/" title="Java虚拟机——学习笔记">http://Kanarienvogels.github.io/2018/07/22/Java虚拟机——学习笔记/</a>
            <span class="copy-path" data-clipboard-text="原文: http://Kanarienvogels.github.io/2018/07/22/Java虚拟机——学习笔记/　　作者: Kanarien" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2018/07/22/Linux系统信息、硬件信息查看/">
                    Linux下系统信息、硬件信息的查看
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2018/07/22/Spring整合Netty、WebSocket的互联网聊天系统/">
                    Spring整合Netty、WebSocket的互联网聊天系统
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">0. 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">1. Java 虚拟机概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">1.1 任务概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">1.2 功能概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">1.3 Java 虚拟机的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">1.4 Java 虚拟机与Java 程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">1.5 虚拟机与物理机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">2. JVM内存结构与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">2.1 数据运行时区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">2.1.1 程序计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">2.1.2 Java虚拟机栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">2.1.3 本地方法栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">2.1.4 Java 堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">2.1.5 方法区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">2.1.6 运行时常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">2.1.7 直接内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">2.2 对象的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">2.2.1 类加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">2.2.2 内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">2.2.3 内存初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">2.2.4 对象头设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">2.2.5 构造函数执行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">2.3 对象的内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">2.4 对象的访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">3. 类加载相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">3.1 类装载器子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">3.1.1 系统装载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">3.1.2 用户自定义类装载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">3.1.3 双亲委派模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">3.2 类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">3.2.1 加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">3.2.2 连接之验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">3.2.3 连接之准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">3.2.4 连接之解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">3.2.5 初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">3.2.6 类装载的具体例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">4. 垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">4.1 垃圾回收概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">4.2 垃圾回收意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">4.3 垃圾回收区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">4.3.1 再述Java堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">4.3.2 再述方法区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">4.4 垃圾回收种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">4.5 垃圾回收时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">4.6 垃圾回收对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">4.7 垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">4.7.1 标记清除算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">4.7.2 复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">4.7.3 标记整理算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">4.7.4 分代收集算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">4.8 垃圾回收器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">5. Class文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">5.1 无关性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">5.2 Class文件内容解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">5.3 字节码指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">5.4 Java虚拟机的实现方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">6. 字节码执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">6.1 栈帧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">6.1.1 局部变量表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">6.2 方法调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">6.2.1 再论类加载的解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">6.2.2 静态分派（静态绑定）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">6.2.3 动态分派（动态绑定）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">6.2.4 动态类型语言</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">6.3 解释执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">6.3.1 编译过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">6.3.2 基于栈的指令集与基于寄存器的指令集</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">7. 编译期优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">7.1 Sun Javac 编译过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">7.1.1 解析和填充符号表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">7.1.2 注解处理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">7.1.3 语义分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">7.1.4 字节码生成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">7.2 Java语法糖——糖衣背后的真实</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">7.2.1 泛型与类型擦除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">7.2.2 遍历循环与变长参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">7.2.3 * 自动装箱、自动拆箱与“==”、“equals()”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">7.2.4 条件编译</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">8. 运行期优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">8.1 JIT编译器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">8.2 解释器与编译器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">8.3 编译对象与触发条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">8.4 编译过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">8.5 编译技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">8.5.1 公共子表达式消除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">8.5.2 数组边界检查消除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">8.5.3 方法内联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text">8.5.4 逃逸分析</span></a></li></ol></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"Java虚拟机——学习笔记　| 无悔的博客小屋　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    
        <section id="comments">
    <style> aside.comment-bar { margin: auto 30px; }</style>
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function(){
            this.page.url = 'http://Kanarienvogels.github.io/2018/07/22/Java虚拟机——学习笔记/';
            this.page.identifier = '2018/07/22/Java虚拟机——学习笔记/';
        };
        var loadComment = function(){
            var d = document, s = d.createElement('script');
            s.src = '//.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        }
    </script>
    
    <script> loadComment(); </script>

</section>


    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/07/22/Linux系统信息、硬件信息查看/" title="上一篇: Linux下系统信息、硬件信息的查看">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2018/07/22/Spring整合Netty、WebSocket的互联网聊天系统/" title="下一篇: Spring整合Netty、WebSocket的互联网聊天系统">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/07/22/Nginx搭配Tomcat作Web服务器/">Nginx搭配Tomcat作Web服务器</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/22/MongoDB数据的导出与导入/">MongoDB数据的导出与导入（Unix 命令）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/22/Linux系统信息、硬件信息查看/">Linux下系统信息、硬件信息的查看</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/22/Java虚拟机——学习笔记/">Java虚拟机——学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/22/Spring整合Netty、WebSocket的互联网聊天系统/">Spring整合Netty、WebSocket的互联网聊天系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/22/Redis——学习笔记/">Redis——学习笔记</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2018 Kanarien
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        $("a[target=_blank]").removeAttr("target");
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>